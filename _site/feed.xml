<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <link>http://localhost:4000</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <description></description>
    <language>en-us</language>
    <pubDate>Tue, 11 Oct 2022 13:07:22 +0800</pubDate>
    <lastBuildDate>Tue, 11 Oct 2022 13:07:22 +0800</lastBuildDate>

    
      <item>
        <title>混沌工程介绍与实践</title>
        <link>http://localhost:4000/%E6%B7%B7%E6%B2%8C%E5%B7%A5%E7%A8%8B%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%9E%E8%B7%B5</link>
        <pubDate>Sat, 08 Oct 2022 00:00:00 +0800</pubDate>
        <author></author>
        <description>&lt;p&gt;&lt;img src=&quot;/public/images/hundun/00.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;什么是混沌工程&quot;&gt;什么是混沌工程&lt;/h2&gt;

&lt;p&gt;混沌工程是在 &lt;a href=&quot;https://principlesofchaos.org/&quot;&gt;混沌工程理论&lt;/a&gt; 一文中提出，但在 2010 年 Netflix 从物理机基础设施迁移到 AWS 过程中，为保证 EC2 实例故障不会对业务造成影响，其团队开发出了杀 EC2 实例的工具，这也是混沌工程的雏形。在 2015 年社区发布《混沌工程理论》一文后，混沌工程开始快速发展。&lt;br /&gt;
混沌工程是在分布式系统上进行实验的学科，旨在提升系统容错性，建立系统抵御生产环境中发生不可预知问题的信心。”打不倒我的必使我强大“，尼采的这句话很好了诠释了混沌工程反脆弱的思想。&lt;/p&gt;

&lt;h2 id=&quot;为什么需要混沌工程&quot;&gt;为什么需要混沌工程&lt;/h2&gt;

&lt;p&gt;分布式系统日益复杂，而且在系统逐渐云化的背景下，系统的稳定性受到很大的挑战。这里从四个角色来说明混沌工程的重要性。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;对于架构师来说，可以验证系统架构的容错能力，比如验证现在提倡的面向失败设计的系统；&lt;/li&gt;
  &lt;li&gt;对于开发和运维，可以提高故障的应急效率，实现故障告警、定位、恢复的有效和高效性。&lt;/li&gt;
  &lt;li&gt;对于测试来说，可以弥补传统测试方法留下的空白，之前的测试方法基本上是从用户的角度去做，而混沌工程是从系统的角度进行测试，降低故障复发率。&lt;/li&gt;
  &lt;li&gt;对于产品和设计，通过混沌事件查看产品的表现，提升客户使用体验。所以说混沌工程面向的不仅仅是开发、测试，拥有最好的客户体验是每个人的目标 所以实施混沌工程，可以提早发现生产环境上的问题，并且可以以战养战，提升故障应急效率和可以使用体验，逐渐建设高可用的韧性系统。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;混沌工程实施原则&quot;&gt;混沌工程实施原则&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/3992234/63409822-858d2f80-c424-11e9-9aac-58f34a0f5c6d.png&quot; alt=&quot;chaos-eng-rules&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;第一条：”建立一个围绕稳定状态行为的假说“，其包含两个含义，一个是定义能直接反应业务服务的监控指标，需要注意的是这里的监控指标并不是系统资源指标，比如CPU、内存等，这里的监控指标是能直接衡量系统服务质量的业务监控。举个例子，一个调用延迟故障，请求的 RT 会变长，对上层交易量造成下跌的影响，那么这里交易量就可以作为一个监控指标。这条原则的另一个含义是故障触发时，对系统行为作出假设以及监控指标的预期变化。&lt;/li&gt;
  &lt;li&gt;第二条指模拟生产环境中真实的或有理论依据的故障场景，比如依赖的服务调用延迟、超时、异常等。&lt;/li&gt;
  &lt;li&gt;第三条建议在生产环境中运行实验，但也不是说必须在生产环境中执行，只是实验环境越真实，混沌工程越有价值，但如果知道系统在某个故障场景下不具备容灾能力，不可以执行此混沌实验，避免资损发生。&lt;/li&gt;
  &lt;li&gt;第四条，持续的执行才能持续的降低故障复发率和提前发现故障，所以需要持续的自动化运行试验。&lt;/li&gt;
  &lt;li&gt;最后一个，混沌工程很重要的一点是控制爆炸半径，也就是试验影响面，防止预期外的资损发生，可以通过环境隔离或者故障注入工具提供的配置粒度来控制。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;混沌工程实施步骤&quot;&gt;混沌工程实施步骤&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;制订混沌实验计划&lt;/li&gt;
  &lt;li&gt;定义系统稳态指标&lt;/li&gt;
  &lt;li&gt;做出系统容错行为假设&lt;/li&gt;
  &lt;li&gt;执行混沌实验&lt;/li&gt;
  &lt;li&gt;检查系统稳态指标&lt;/li&gt;
  &lt;li&gt;记录&amp;amp;恢复混沌实验&lt;/li&gt;
  &lt;li&gt;修复发现的问题&lt;/li&gt;
  &lt;li&gt;自动化持续进行验证&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;推荐工具产品&quot;&gt;推荐工具产品&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/3992234/63409859-9473e200-c424-11e9-89bc-09eff69dd390.jpg&quot; alt=&quot;awesome-chaos-engineering.png&quot; /&gt; 大家可以从工具的场景丰富度、类型、易用性等方面来选择一款合适的工具，awesome-chaos-engineering Github 项目收纳了一些开源的混沌工程工具，在 CNCF Landscape 中混沌工程作为单独的一个领域存在，并且收纳了一些主流的工具，包含阿里巴巴开源的 ChaosBlade 工具和 AHAS 阿里云产品。 &lt;img src=&quot;https://user-images.githubusercontent.com/3992234/63409944-b705fb00-c424-11e9-887f-5e057b31536a.jpg&quot; alt=&quot;cncf-landscape.png&quot; /&gt; 下文重点介绍 ChaosBlade 及其相关实践。&lt;/p&gt;

&lt;h3 id=&quot;chaosblade&quot;&gt;ChaosBlade&lt;/h3&gt;

&lt;p&gt;ChaosBlade 中文名混沌之刃，是一款混沌实验实施工具，支持丰富的实验场景，比如应用、容器、基础资源等。工具使用简单，扩展方便，其遵循社区提出的混沌实验模型。Github 地址：https://github.com/chaosblade-io/chaosblade&lt;/p&gt;

&lt;h4 id=&quot;功能和特点&quot;&gt;功能和特点&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;场景丰富度高&lt;/strong&gt; ChaosBlade 支持的混沌实验场景不仅覆盖基础资源，如 CPU 满载、磁盘 IO 高、网络延迟等，还包括运行在 JVM 上的应用实验场景，如 Dubbo 调用超时和调用异常、指定方法延迟或抛异常以及返回特定值等，同时涉及容器相关的实验，如杀容器、杀 Pod。后续会持续的增加实验场景。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用简洁，易于理解&lt;/strong&gt; ChaosBlade 通过 CLI 方式执行，具有友好的命令提示功能，可以简单快速的上手使用。命令的书写遵循阿里巴巴集团内多年故障测试和演练实践抽象出的故障注入模型，层次清晰，易于阅读和理解，降低了混沌工程实施的门槛。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;动态加载，无侵入&lt;/strong&gt; ChaosBlade采用动态故障注入的方式，执行混沌实验时用户系统不需要做任何系统改造或发布，开箱即用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;场景扩展方便&lt;/strong&gt; 所有的 ChaosBlade 实验执行器同样遵循上述提到的故障注入模型，使实验场景模型统一，便于开发和维护。模型本身通俗易懂，学习成本低，可以依据模型方便快捷的扩展更多的混沌实验场景。&lt;/p&gt;

&lt;h4 id=&quot;使用方式&quot;&gt;使用方式&lt;/h4&gt;

&lt;p&gt;在 ChaosBlade Release 页面下载最新版本的包，解压即用。如创建一个 CPU 满载实验，命令为：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;blade create cpu fullload
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;具体使用方式可详见：&lt;a href=&quot;https://github.com/chaosblade-io/chaosblade/wiki/%E6%96%B0%E6%89%8B%E6%8C%87%E5%8D%97&quot;&gt;ChaosBlade 新手指南&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;混沌实验模型&quot;&gt;混沌实验模型&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/3992234/63409808-80c87b80-c424-11e9-9fa8-26b52e1fef73.jpg&quot; alt=&quot;&quot; /&gt; 该模型分四次，层层递进，很清晰的表达出对什么组件做实验，实验范围是什么，实验触发的匹配规则有哪些，执行什么实验。该模型简洁、通用，语言领域无关、易于实现。阿里集团内的 C++、NodeJS、Dart 应用以及容器平台的实验场景都基于此模型实现。此模型具有很重要的意义，依据此模型可以更精准的描述、更好的理解、更方便沉淀实验场景以及发掘更多的场景。依据此模型实现的工具更加规范、简洁。实验模型介绍可详见：&lt;a href=&quot;https://github.com/chaosblade-io/chaosblade/wiki/%E6%B7%B7%E6%B2%8C%E5%AE%9E%E9%AA%8C%E6%A8%A1%E5%9E%8B&quot;&gt;混沌实验模型介绍&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&quot;混沌工程实践案例&quot;&gt;混沌工程实践案例&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/3992234/63409672-35ae6880-c424-11e9-8a93-f4b10bdf6afb.png&quot; alt=&quot;Screen Shot 2019-08-21 at 2.44.42 P&quot; /&gt; 此拓扑图来自于阿里云 AHAS 产品架构感知功能，可自动感知架构拓扑，并且可以展示进程、网络、节点等数据。这个分布式服务 Demo 分三级调用，consumer 调用 provider，provider 调用 base，同时 provider 还调用 mk-demo 数据库，provider 和 base 服务具有两个实例，在 AHAS 架构拓扑图上，我们点击一个实例节点，可以到非常清晰的调用关系。我们后面结合这个 Demo 去讲解实践。&lt;/p&gt;

&lt;h3 id=&quot;验证监控告警&quot;&gt;验证监控告警&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/3992234/63409276-6e017700-c423-11e9-945d-4312005ba27e.png&quot; alt=&quot;Screen Shot 2019-08-21 at 2.43.58 P&quot; /&gt; 案例一，我们验证系统的监控告警性有效性。按照前面提到的混沌工程实施步骤，那么这个案例执行的实验场景是数据库调用延迟，我们先定义监控指标：慢 SQL 数和告警信息，做出期望假设：慢 SQL 数增加，钉钉群收到慢 SQL 告警。接下来执行实验。我们直接使用 ChaosBlade 工具执行，可以看下左下角，我们对 demo-provider 注入调用 mysql 查询时，若数据库是 demo 且表名是 d_discount，则对 50% 的查询操作延迟 600 毫秒。我们使用阿里云产品 ARMS 做监控告警。大家可以看到，当执行完混沌实验后，很快钉钉群里就收到了报警。所以我们对比下之前定义的监控指标，是符合预期的。但需要注意的是这次符合预期并不代表以后也符合，所以需要通过混沌工程持续性的验证。出现慢 SQL，可通过 ARMS 的 &lt;a href=&quot;https://help.aliyun.com/document_detail/63796.html&quot;&gt;链路追踪&lt;/a&gt; 来排查定位，可以很清楚的看出哪条语句执行慢。&lt;/p&gt;

&lt;h3 id=&quot;案例二&quot;&gt;案例二&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/3992234/63409297-778adf00-c423-11e9-9179-d991eab7b6db.png&quot; alt=&quot;Screen Shot 2019-08-21 at 2.44.07 P&quot; /&gt; 前面讲了一个符合预期的案例，我们再来看一个不符合预期的。此案例是验证系统异常实例隔离的能力，我们的 Demo 中 consumer 调用 provider 服务，provider 服务具有两个实例，我们对其中一个注入延迟故障，监控指标是 consumer 的 QPS，稳态在 510 左右。我们做的容错假设是系统会自动隔离或下线出问题的服务实例，防止请求路由的此实例，所有 QPS 会有短暂的下跌，但很快会恢复。这个案例，我们使用阿里云 AHAS 混沌实验平台来执行，我们对 demo-provider-1 注入延迟故障，基于此平台可以很方便的执行混沌实验。执行混沌实验后，QPS 下跌到 40 左右，很长时间没有自动恢复，所以不符合预期，我们通过人工的方式对该异常的实例做下线处理，很快就看到，consumer 的 QPS 恢复正常。所以我们通过混沌工程发现了系统问题，我们后面需要做就是记录此问题，并且推动修复，后续做持续性的验证。&lt;/p&gt;

&lt;p&gt;原文链接：https://stabilityman.github.io/docs/prevention/resilience/混沌工程介绍与实践.html&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>为什么 Kubernetes 要替换 Docker</title>
        <link>http://localhost:4000/%E4%B8%BA%E4%BB%80%E4%B9%88-Kubernetes-%E8%A6%81%E6%9B%BF%E6%8D%A2-Docker</link>
        <pubDate>Sun, 11 Sep 2022 00:00:00 +0800</pubDate>
        <author></author>
        <description>&lt;p&gt;&lt;img src=&quot;/public/images/k8s_docker/00.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Kubernetes 是今天容器编排领域的事实标准，而 Docker 从诞生之日到今天都在容器中扮演着举足轻重的地位，也都是 Kubernetes 中的默认容器引擎。然而在 2020 年 12 月，Kubernetes 社区决定着手移除仓库中 Dockershim 相关代码&lt;a href=&quot;#fn:1&quot;&gt;1&lt;/a&gt;，这对于 Kubernetes 和 Docker 两个社区来说都意义重大。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/kubelet-and-containers-2021-03-10-16153845432597.png&quot; alt=&quot;kubelet-and-containers&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;图 1 - Dockershim&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;相信大多数的开发者都听说过 Kubernetes 和 Docker，也知道我们可以使用 Kubernetes 管理 Docker 容器，但是可能没有听说过 Dockershim，即 Docker 垫片。如上图所示，Kubernetes 中的节点代理 Kubelet 为了访问 Docker 提供的服务需要先经过社区维护的 Dockershim，Dockershim 会将请求转发给管理容器的 Docker 服务。&lt;/p&gt;

&lt;p&gt;其实从上面的架构图中，我们就能猜测出 Kubernetes 社区从代码仓库移除 Dockershim 的原因：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Kubernetes 引入容器运行时接口（Container Runtime Interface、CRI）隔离不同容器运行时的实现机制，容器编排系统不应该依赖于某个具体的运行时实现；&lt;/li&gt;
  &lt;li&gt;Docker 没有支持也不打算支持 Kubernetes 的 CRI 接口，需要 Kubernetes 社区在仓库中维护 Dockershim；&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;可扩展性&quot;&gt;可扩展性&lt;/h2&gt;

&lt;p&gt;Kubernetes 通过引入新的容器运行时接口将容器管理与具体的运行时解耦，不再依赖于某个具体的运行时实现。很多开源项目在早期为了降低用户的使用成本，都会提供开箱即用的体验，而随着用户群体的扩大，为了满足更多定制化的需求、提供更强的可扩展性，会引入更多的接口。Kubernetes 通过下面的一系列接口为不同模块提供了扩展性：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/kubernetes-extensions-2021-03-10-16153845432607.png&quot; alt=&quot;kubernetes-extensions&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;图 2 - Kubernetes 接口和可扩展性&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Kubernetes 在较早期的版本中就引入了 CRD、CNI、CRI 和 CSI 等接口，只有用于扩展调度器的调度框架是 Kubernetes 中比较新的特性。我们在这里就不展开分析其他的接口和扩展了，简单介绍一下容器运行时接口。&lt;/p&gt;

&lt;p&gt;Kubernetes 早在 1.3 就在代码仓库中同时支持了 rkt 和 Docker 两种运行时，但是这些代码为 Kubelet 组件的维护带来了很大的困难，不仅需要维护不同的运行时，接入新的运行时也很困难；容器运行时接口（Container Runtime Interface、CRI）是 Kubernetes 在 1.5 中引入的新接口，Kubelet 可以通过这个新接口使用各种各样的容器运行时。其实 CRI 的发布就意味着 Kubernetes 一定会将 Dockershim 的代码从仓库中移除。&lt;/p&gt;

&lt;p&gt;CRI 是一系列用于管理容器运行时和镜像的 gRPC 接口，我们能在它的定义中找到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RuntimeService&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ImageService&lt;/code&gt; 两个服务&lt;a href=&quot;#fn:2&quot;&gt;2&lt;/a&gt;，它们的名字很好地解释了各自的作用：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;service RuntimeService {
    rpc Version(VersionRequest) returns (VersionResponse) {}

    rpc RunPodSandbox(RunPodSandboxRequest) returns (RunPodSandboxResponse) {}
    rpc StopPodSandbox(StopPodSandboxRequest) returns (StopPodSandboxResponse) {}
    rpc RemovePodSandbox(RemovePodSandboxRequest) returns (RemovePodSandboxResponse) {}
    rpc PodSandboxStatus(PodSandboxStatusRequest) returns (PodSandboxStatusResponse) {}
    rpc ListPodSandbox(ListPodSandboxRequest) returns (ListPodSandboxResponse) {}

    rpc CreateContainer(CreateContainerRequest) returns (CreateContainerResponse) {}
    rpc StartContainer(StartContainerRequest) returns (StartContainerResponse) {}
    rpc StopContainer(StopContainerRequest) returns (StopContainerResponse) {}
    rpc RemoveContainer(RemoveContainerRequest) returns (RemoveContainerResponse) {}
    rpc ListContainers(ListContainersRequest) returns (ListContainersResponse) {}
    rpc ContainerStatus(ContainerStatusRequest) returns (ContainerStatusResponse) {}
    rpc UpdateContainerResources(UpdateContainerResourcesRequest) returns (UpdateContainerResourcesResponse) {}
    rpc ReopenContainerLog(ReopenContainerLogRequest) returns (ReopenContainerLogResponse) {}

    ...
}

service ImageService {
    rpc ListImages(ListImagesRequest) returns (ListImagesResponse) {}
    rpc ImageStatus(ImageStatusRequest) returns (ImageStatusResponse) {}
    rpc PullImage(PullImageRequest) returns (PullImageResponse) {}
    rpc RemoveImage(RemoveImageRequest) returns (RemoveImageResponse) {}
    rpc ImageFsInfo(ImageFsInfoRequest) returns (ImageFsInfoResponse) {}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;对 Kubernetes 稍有了解的人都能从上面的定义中找到一些熟悉的方法，它们都是容器运行时需要暴露给 Kubelet 的接口。Kubernetes 将 CRI 垫片实现成 gRPC 服务器与 Kubelet 中的客户端通信，所有的请求都会被转发给容器运行时处理。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/cri-and-container-runtimes-2021-03-10-16153845432613.png&quot; alt=&quot;cri-and-container-runtimes&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;图 3 - Kubernetes 和 CRI&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Kubernetes 中的声明式接口非常常见，作为声明式接口的拥趸，CRI 没有使用声明式的接口是一件听起来『非常怪异』的事情&lt;a href=&quot;#fn:3&quot;&gt;3&lt;/a&gt;。不过 Kubernetes 社区考虑过让容器运行时重用 Pod 资源，这样容器运行时可以实现不同的控制逻辑来管理容器，能够极大地简化 Kubelet 和容器运行时之间的接口，但是社区出于以下两点考虑，最终没有选择声明式的接口：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;所有的运行时都需要重新实现相同的逻辑支持很多 Pod 级别的功能和机制；&lt;/li&gt;
  &lt;li&gt;Pod 的定义在 CRI 设计时演进地非常快，初始化容器等功能都需要运行时的配合；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;虽然社区最终为 CRI 选择了命令式的接口，但是 Kubelet 仍然会保证 Pod 的状态会不断地向期望状态迁移。&lt;/p&gt;

&lt;h2 id=&quot;不兼容接口&quot;&gt;不兼容接口&lt;/h2&gt;

&lt;p&gt;与容器运行时相比，Docker 更像是一个复杂的开发者工具，它提供了从构建到运行的全套功能。开发者可以很快地上手 Docker 并在本地运行并管理一些 Docker 容器，然而在集群中运行的容器运行时往往不需要这么复杂的功能，Kubernetes 需要的只是 CRI 中定义的那些接口。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/docker-and-cri-2021-03-10-16153845432620.png&quot; alt=&quot;docker-and-cri&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;图 4 - Docker &amp;amp; CRI&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Docker 的官方文档加起来可能有一本书的厚度，相信没有任何开发者可以熟练运用 Docker 提供的全部功能。而作为开发者工具，虽然 Docker 中包含 CRI 需要的所有功能，但是都需要实现一层包装以兼容 CRI。除此之外，社区提出的很多新功能都没有办法在 Dockershim 中实现，例如 cgroups v2 以及用户命名空间。&lt;/p&gt;

&lt;p&gt;Kubernetes 作为比较松散的开源社区，每个成员尤其是各个 SIG 的成员都只会在开源社区上花费有限的时间，而维护 Kubelet 的 sig-node 又尤其繁忙，很多新的功能都因为维护者没有足够的精力而被搁置，所以既然 Docker 社区看起来没有打算支持 Kubernetes 的 CRI 接口，维护 Dockershim 又需要花费很多精力，那么我们就能理解为什么 Kubernetes 会移除 Dockershim 了。&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;今天的 Kubernetes 已经是非常成熟的项目，它的关注点也逐渐从提供更完善的功能转变到提供更好的扩展性，这样才能满足不同场景和不同公司定制化的业务需求。Kubernetes 在过去因为 Docker 的热门而选择 Docker，而在今天又因为高昂的维护成本而放弃 Docker，我们能够从这个过程中体会到容器领域的发展和进步。&lt;/p&gt;

&lt;p&gt;移除 Docker 的种子其实从 CRI 发布时就种下了，Dockershim 一直都是 Kubernetes 为了兼容 Docker 获得市场采取的临时决定，对于今天已经统治市场的 Kubernetes 来说，Docker 的支持显得非常鸡肋，移除代码也就顺理成章了。我们在这里重新回顾一下 Kubernetes 在仓库中移除 Docker 支持的两个原因：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Kubernetes 在早期版本中引入 CRI 摆脱依赖某个具体的容器运行时依赖，屏蔽底层的诸多实现细节，让 Kubernetes 能够更关注容器的编排；&lt;/li&gt;
  &lt;li&gt;Docker 本身不兼容 CRI 接口，而且官方并没有实现 CRI 的打算，同时也不支持容器的一些新需求，所以 Dockershim 的维护成为了社区的想要摆脱负担；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;原文链接：https://draveness.me/whys-the-design-kubernetes-deprecate-docker/&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>什么是工程师文化</title>
        <link>http://localhost:4000/%E4%BB%80%E4%B9%88%E6%98%AF%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%96%87%E5%8C%96</link>
        <pubDate>Thu, 28 Jul 2022 00:00:00 +0800</pubDate>
        <author></author>
        <description>&lt;p&gt;&lt;img src=&quot;/public/images/sys_principle/00.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;为什么要工程师文化&quot;&gt;为什么要工程师文化&lt;/h2&gt;

&lt;p&gt;看看最近二十年来社会的发展，计算机和互联网已经渗透到了这个社会的每一个角落，各式各样的计算机技术成为了整个世界发展的强大引擎，各式各样的创新，无论是业务创新还是技术创新，都是依托于技术的快速演进，技术成了解放生产力提高社会运作的效率的中坚力量。以美帝为首的技术创新公司着着实实的改变着这个世界和人类的生活和生产习惯。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;今天，每个从事计算机行业的技术人员都应该感到幸运，因为，我们不但选对了行业，也出生在了正确的时代，可以感受到前所未有的刺激和变化，相比起我们的父辈，我们的人生，能经历这样的时代，实在是一种幸运。&lt;/strong&gt;所以，选对了职业并出生在了正确的年代的我们，此时只需要思考的一个问题，那就是，我是否呆在了正确的地方用正确的方式做事？&lt;/p&gt;

&lt;p&gt;在我看来，这个世界上有三种商业公司，&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;运营或销售驱动型的公司&lt;/strong&gt;。这类的公司以运营和营销见长，技术对于他们来说，更多的只是为了支持大规模的营销活动，以及成本上的控制，所以，基本上来说不太需要技术创新。这种公司最大的问题就是缺乏安全感。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;产品驱动型的公司&lt;/strong&gt;。这类公司以产品见长，通过创造能提升用户生活体验的产品见长，技术对于他们来说，除了支持大规模的在线用户之外，他们会更多的去寻找那些为了增强用户体验，提高整个业务流程效率的技术创新。比如：UI的交互方面的，整个业务流程方面的。这种公司最大的问题，就是容易被别人模仿和抄袭。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;技术驱动型的公司&lt;/strong&gt;。这类的公司相信技术能改变世界，他们更多的是用强大的工程技术来创造有颠覆性的东西，更多的是用各种自动化的技术取代人类。比如：近代的蒸汽机技术取代了大量的人工，数字技术取代了大量信息传递的人工，现代，这类公司还希望通过人工智能来取代愚蠢的人类来做决定。这种公司最大的问题就是可能做出叫好不叫座的东西。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这三种公司都可能成功，也都有问题，但是，无一例外，他们都需要强大的技术支撑，只不过，他们把技术所放在的位置不一样。&lt;/p&gt;

&lt;p&gt;无论你有多么的看不起技术人员，你都无法否认，你今天的生活相当的依赖这帮工程师，没有他们，你恐怕都不知道怎么生活了。邓爷爷几十年前就说过——“科学技术是第一生产力” ，无论什么样的科学技术的理论要落地都会依赖于工程技术有多先进。&lt;/p&gt;

&lt;p&gt;所以，&lt;strong&gt;在今天，作为一个IT或互联网公司，“工程师文化”不是一个问题，而是一个常识&lt;/strong&gt;！&lt;/p&gt;

&lt;h2 id=&quot;工程师文化的特征&quot;&gt;工程师文化的特征&lt;/h2&gt;

&lt;p&gt;我下面罗列的这些特征，来源于：Google的《&lt;a href=&quot;https://book.douban.com/subject/26582822/&quot;&gt;重新定义公司&lt;/a&gt;》，我在Amazon的工作经历，37Signals的《&lt;a href=&quot;https://coolshell.cn/articles/9156.html&quot;&gt;Rework&lt;/a&gt;》，Quora上的 &lt;a href=&quot;https://www.quora.com/What-makes-a-good-engineering-culture&quot;&gt;What Makes Good Engineering Culture?&lt;/a&gt;  Slideshare上的 &lt;a href=&quot;http://www.slideshare.net/edmondlau/what-makes-a-great-engineering-culture&quot;&gt;What Makes Good Engineering Culture&lt;/a&gt;，以及我最近这半年来的一些实践。&lt;/p&gt;

&lt;p&gt;简单说来，&lt;strong&gt;我可以简单的把这多的工程师文化的总结成两大类：“自由” 和 “效率”&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;本来还应该有个“创新”，但我个人认为，&lt;strong&gt;创新的前提是——在自由的环境下对提高效率的痴迷，就一定会发生创新。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;创新不是凭空出现新的东西，其实，&lt;strong&gt;观察一下人类的发展史，不难发现，几乎所有的创新基本上跳出原来的思维模式用新的思维模式对原有问题的效率进行质的提升&lt;/strong&gt;。比如：通信、交通、医疗、教育、生活……几乎全都是在优化效率。&lt;/p&gt;

&lt;p&gt;所以，如果你的精神不自由，你很难跳出老的思维模式，你用老的思维模式你一定不会想到新的方法和方式，如果不是对效率的提升，这个创新可能会不接地气。&lt;/p&gt;

&lt;p&gt;因此，我认为，工程师文化就是自由加效率！&lt;/p&gt;

&lt;h2 id=&quot;自由&quot;&gt;自由&lt;/h2&gt;

&lt;p&gt;首先，工程师文化意味的创新文化，工程师都是有创新冲动的人，因为手里有创造技能的人通常都会有想创造点什么的冲动。而创新的源泉水来源于精神的解放，精神自由才会引发各式各样的奇思怪想，才会有常人觉得不可能的疯狂想法和想像力，而这些想法和想像力导致了创新。&lt;/p&gt;

&lt;p&gt;精神上的自由具体表现在：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;自我驱动&lt;/strong&gt;。自己管理自己是最好的管理。最失败的管理就是家长和保姆式的管理。兴趣出发的工作才可能迸发出真正的动力。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;灵活的工作时间和地点&lt;/strong&gt;。工程师们更多的是脑力工作，而不是体力工作，工作上时间和地点的自由安排可以让工程师们的脑力工作更有效。Remote是一个很不错的工作方式，开源社区基本上都是这钟方式。和Remote有关的话题可参看37Signals的这本书《&lt;a href=&quot;https://book.douban.com/subject/25861795/&quot;&gt;Remote&lt;/a&gt;》&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;信息平等&lt;/strong&gt;。这意味着，全体员工得到的是原始信息，而不是被管理者们层层加工消化后的信息，信息的屏蔽很容易造成误解和完全错误的行为。信息的平等，大的包括战略、方向、目标、财务，小的包括文档、代码、和知识的共享等。同样，也表现在意见表达上，任何人都有可能表达自己的意见和建议的平等机会，这样才会激发出更多的思路和思辩，从而有不同的更好的思路出现。而不是，大家都看到了问题，而没有人敢说。在Google除了代码全员共享，还有Thanks God, It’s Friday的文化，每周五，高管们会出来，任员工提各种尖锐的问题，在Amazon，代码和文档基本上全员开放，包括财务报表也对员工开放，另外，除了所有的NB的Principle SDE隔三岔五都会有一个Principle Talk（有很多Talk相当令人开脑洞），还有Amazon内部的Up the River文化，每年会选出一批公司最聪明最有想法的人集思会，讨公司下一步的和战略，并可以把相应的KPI直接按给Senior VP。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;不害怕错误&lt;/strong&gt;。处理错误的正确的姿势是分析总结教训，而不是惩罚故障人。前者让人改善进步，后者让人萎缩不前。最大的错误就是不敢犯错，最大的问题就是不敢直面问题。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;宽松的审批系统甚至没有审批系统&lt;/strong&gt;。审批通常暗示着三件事，1）对人的不完全信任，2）繁琐的流程，3）思维上的束缚。这些都是创新和想像力的天敌。一个公司的监管、审批、流程越重，这个公司的活力也就越差。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;20%的自由时间&lt;/strong&gt;。这是Google公司提出来的，员工有20%自由的时间做自己想做的项目，Gmail就是这么出来的。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;效率&quot;&gt;效率&lt;/h2&gt;

&lt;p&gt;工程师天生是追求效率的。有人说认为程序员花大量的时间做自动化的工具，还不如人肉的效率高，比如，写自动化的脚本花5个小时，而重复做这件事200次只花3个小时。有这样的理解的人根本不懂工程。&lt;/p&gt;

&lt;p&gt;一方面，这个工具可以共享重用，更多的人可以从中受益，这次我花5个小时开发这个工具，下次只用1小时改一下就可以用在别的地方，这是着眼于未来而不是眼下的成本。更重要的是，这是一种文化，一种提高效率的文化，他会鼓励和激发出更多的这样的事情发生。&lt;strong&gt;如果你因为一个程序员花大量的时间开发自动化的工具，而认为这个程序员没有效率，对之批评甚至惩罚的话，那么你就扼杀了提高效率的文化&lt;/strong&gt;（关于效率，大家可以看看我的另一篇文章《&lt;a href=&quot;https://coolshell.cn/articles/10217.html&quot;&gt;关于加班和效率&lt;/a&gt;》，你会真正了解什么是效率）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;人类之所以比别的动物聪明就是会使用和发明工具&lt;/strong&gt;，而古语也有云：“工欲善其事，必先利其器”，看看美军的装备你就知道战争工具的好坏有多重要了，&lt;strong&gt;一个公司的强大之处在执行力，而执行力的强大之处在于你有什么样的支持工具。这些，已经不是工程师文化，而是人类发展的文化&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;针对于工程师文化来说，尤其是软件工程，提升工程效率的具体表现如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;简化&lt;/strong&gt;。简化不是简陋，简单的东西通常意味着用户更好理解，也意味着更容易的维护和运维。就像阿里推行的“小而美”，就像乔布期推崇的“没有产品手册简单易用的产品”，就像Amazon推行的Working Backwards里说的那样，一个新的产品或功能，产品经理需要写三个文档：媒体公关文、用户手册、常见问题，三个文档总共加起来不超过两页A4纸，且不准用任何图片说明，目的就是为了让产品简化和容易使用。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;残酷无情的推行自动化&lt;/strong&gt;。编写程序的最本质的目的就是自动化，看看人类发展史上自动化了多少东西。&lt;strong&gt;对于自动化来说，不仅仅只是消除人肉的重复劳动，更重要的是，很多事情人完全干不过机器。&lt;/strong&gt;比如：加一台机器，程序在秒级就可以完成，而人是永远不可能达到这样的速度的，再比如：电商中用程序管理数量巨大的订单的自动化系统，加再多的人都完成的不可能像机器那样完成的又好又快。自动化需要大力开发提高生产力的工具，比如：持续集成，持续部署，自动化运维，基础自动化运维，甚至自动化的运营工具。（Amazon的软件工程中对自动化和简代相当迷恋）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;避免无效率的组织架构和无效率的管理&lt;/strong&gt;。这体现在这些方面：1）扁平化的组织架构，2）努力用自动化工具取代支持型的工作，3）不超过10个人的全栈小团队，4）不按人员的技能分工而是按其负责的产品或功能分工（关于分工，请参看《&lt;a href=&quot;https://coolshell.cn/articles/17295.html&quot;&gt;让我们来谈谈分工&lt;/a&gt;》），5）开会不是解决问题，开会是表决提案，6）通过产品的目标或信条Tenets来减少沟通和决策过程（Amazon里的每个部门，每个团队，每个产品都有自己的Tenets，这个Tenets标明了要什么不要什么，这样可以避免很多扯皮和难缠的trade-off的决择，比如：AWS的几个信条：运维是最高优级的——这意味着只要是会让运维变得复杂的需求都可能会工程团队被拒掉，Throughput &amp;amp; Latency不能更差——这意味着，功能要为性能让路，因为性能变差了，用户就要买更多的资源）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;正确的组件抽象&lt;/strong&gt;。抽象是简化的一部份，一方面，抽象意味着重用和通用，另一方面抽象意味着强大的扩展性，以适配各种可能性。最重要的是，抽象意味着技术能力的输出，无论是内部的其它团队还外部的团队。比如：Google的MapReduce/BigTable/ProtoBuffer，FaceBook的Thrift，还有Amazon内部的WebService框架Coral Service、处理日志监控的Timber，以及全线AWS产品都用到的Amazon Lock Framework（一个分布式锁框架）……&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;开发高质量的产品&lt;/strong&gt;。因为高质量的代码，不但可以容易的修改和维护，还可以因为少处理线上故障，从而有更多的时间去为未来做更多创造性的工作。这意味着需要有非常严谨的Design Review，Code Review，以及测试，关于Code Review，可以参看这篇文章《&lt;a href=&quot;https://coolshell.cn/articles/11432.html&quot;&gt;从Code Review 谈如何做技术&lt;/a&gt;》，关于严谨的测试，可以参看这篇文章《&lt;a href=&quot;https://coolshell.cn/articles/17381.html&quot;&gt;如何做性能测试&lt;/a&gt;》&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;不断的提高标准以及招聘最好的人&lt;/strong&gt;。取法其上，得乎其中，取法其中，得乎其下，取法其下，法不得也。如果一个公司或一个团队想变得越来越好，越来越强大的话，就必需要不断的提高自己的工作标准，提高工作标准意味着要不断地培养和招聘更好的人。在Amazon和Google的招聘官中都有一个叫Bar Rasier的人，这个人就是为了提高招聘标准而设立的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;创建一个持续改善的文化&lt;/strong&gt;。一个好的组织，一个好的团队，是需要不断反思前进的，这需要全体员工一起来的。微观层面上，在项目做完后需要有一个总结会分析项目中的得失，在故障出现后，需要有故障分析会，反思得失，在Amazon，严重的故障，需要写一个COE（Correction of Errors）的文档，其中有一节叫“Ask 5 Whys”，让你自己问自己至少5个为什么。在宏观层面，一个公司每年都应该做一定的工作数据分析或是员工调查，比如，是否招聘到了不错的人、工作的投入产出比，员工在哪些地方花时间了，等等，然后不断的用技术手段来改善。（Amazon每年的工程师员工调查表是我活那么大见过的最细最细的调查表了， 问题除了对公司、经理、文化的，还有从，日常工作、开发环境、持结集成，测试自动化、产品质量、软件架构、软件维护、线上问题处理、年度计划、数据仓库建设、通用工具投票……这个员工调查直接导致公司的对工程的投资方向）&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;工程师文化如何落地&quot;&gt;工程师文化如何落地&lt;/h2&gt;

&lt;p&gt;如果你要让任何文化在公司内得到执行，你有下面几个手段可以选择：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;通过政治手段：你需要把住三个地方——招聘、绩效考核 &amp;amp; 升职&lt;/strong&gt;。比如，你要落地工程师文化中的简化和自动化，那你你在招聘的时候，你需要把懂简化和喜欢自动化的人招进来，然后在绩效考核和升职的地方设置上一条硬性指标——你今年简化了什么？自动化了什么？如果没有，对不起不但不能升职，绩效可能还不达标。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;通过经济手段：让不做这事的成本 &amp;gt; 要做这个的成本。&lt;/strong&gt;然后，正常的人类都会选择成本低的方案。比如，如果你要推行Design/Code Review/UT以提高质量，你就把QA和OPS团队全挪到一边去，让Dev团队自己测试，自己负责，这样等这些Dev重复多次手动测试，处理多次线上的弱智故障，他们就会自然而然的写自动化测试和做Code Review了，而QA和OPS团队只是帮Dev你做工具罢了，而测试和运维的事全是你DEV的Ownership，出了故障也是Dev自己负责，于是，他们就会发现，不做Code Review和UT的成本远远大于做Code Review/UT的成本，他们就会去做成本低的事的。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最后，工程师文化要落地，还有几个小条件，&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;第一，团队要小，Ownership很重要，Eat Your Own Dog Food。&lt;/strong&gt; 没有人帮你擦屁股，自己的屎自己吃，没有痛苦，不会产生想进步的动力。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;第二，热爱学习和尝试&lt;/strong&gt;，学习尝试新的技术，开拓眼界，学习尝试新的思维方式，否则，呆在原地，原有的思维方式只会让你在原地打转转。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;第三，老板更多的相信技术而不是管理&lt;/strong&gt;。相信技术会用技术来解决问题，相信管理，那就只会有制度、流程和价值观来解决问题。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;其它&quot;&gt;其它&lt;/h2&gt;

&lt;p&gt;说了这么多，时代还在发展，不过，这是我这么多年经历或看到的工程师文化的东西了。最后吐几个槽——&lt;/p&gt;

&lt;p&gt;对于996和加班这个事，对于工程师来说从来都不是问题，在解决技术问题或是创造的时候，工程师是个很自觉的群体，基本不需要有别人驱动，工程师是最乐意Work Hard的人了。我相信几乎所有走上编程这个职业的人来说，基本上都是兴趣所至，觉得编程很有趣，但却被各个公司996搞得对编程毫无兴趣。为什么，你们这些公司要向中国的教育学习呢？人家本来对这事有比较高的兴趣的，但就是要通过考试/KPI/996这些东西把人家的兴趣一点一点的磨灭掉，把人变成机器、奴隶、牲口，&lt;strong&gt;让人对学习和工作产生了厌倦和讨厌，会是你们这些管理者们所希望的？是不是只有把人变得不思进取了，你们才会管理？&lt;/strong&gt;就像《&lt;a href=&quot;https://coolshell.cn/articles/4951.html&quot;&gt;软件开发中的两种管理方式&lt;/a&gt;》中说的第一种人一样？&lt;/p&gt;

&lt;p&gt;另外，我不知道，为什么我一说这些东西，就会有很多人（包括程序员自己）来和我说我是个理想主义者，这些已经不是什么理想了，已被很多成功的公司用了很多很多年了。只是你没有见到过罢了。还有的人说，因为中国的国情不同。这更让我费解了。这让我想到了当年大清朝派了一堆人出国考察后回来后，说外国的那套共和的东西不符合中国国情，最终也在历史的潮流中被淹没掉了。另外，什么叫“中国的国情不同”？中国有全世界数一数二的互联网用户，也有全世界数一数二的市场，不再是以前那个一穷二白的年代了，中国的国情到底有哪些不同呢？&lt;/p&gt;

&lt;p&gt;我不知道各位工程师是为什么活的？但我觉得，&lt;strong&gt;我们选择了一个刺激的职业，也赶上了这个行业大发展的时代，我们不妨扪心自问一下，你是否愿意让自己的能力、青春和热情就这样被磨灭了？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;原文链接：https://coolshell.cn/articles/17497.html&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>做系统架构的一些原则</title>
        <link>http://localhost:4000/%E5%81%9A%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8E%9F%E5%88%99</link>
        <pubDate>Sun, 15 May 2022 00:00:00 +0800</pubDate>
        <author></author>
        <description>&lt;p&gt;&lt;img src=&quot;/public/images/sys_principle/00.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这篇文章所说的这些架构上的原则，一般适用于相对比较复杂的业务，如果只是一些简单和访问量不大的应用，那么你可能会得出相反的结论&lt;/p&gt;

&lt;h2 id=&quot;原则一关注于真正的收益而不是技术本身&quot;&gt;原则一：关注于真正的收益而不是技术本身&lt;/h2&gt;

&lt;p&gt;对于软件架构来说，我觉得第一重要的是架构的收益，如果不说收益，只是为了技术而技术，而没有任何意义。对于技术收益来说，我觉得下面这几个收益是非常重要的：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;是否可以降低技术门槛加快整个团队的开发流程&lt;/strong&gt;。能够加快整个团队的工程流程，快速发布，是软件工程一直在解决的问题，所以，系统架构需要能够进行并行开发，并行上线和并行运维，而不会让某个团队成为瓶颈点。（注：就算拖累团队的原因是组织构架，也不妨碍我们做出并行的系统架构设计）&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;是否可以让整个系统可以运行的更稳定&lt;/strong&gt;。要让整个系统可以运行的更为的稳定，提升整个系统的 SLA，就需要对有计划和无计划的停机做相应的解决方案（参看《&lt;a href=&quot;https://coolshell.cn/articles/17459.html&quot; title=&quot;关于高可用的系统&quot;&gt;关于高可用的架构&lt;/a&gt;》）&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;是否可以通过简化和自动化降低成本&lt;/strong&gt;。最高优化的成本是人力成本，人的成本除了慢和贵，还有经常不断的 human error。如果不能降低人力成本，反而需要更多的人，那么这个架构设计一定是失败的。除此之外，是时间成本，资金成本。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果一个系统架构不能在上面三个事上起到作用，那就没有意义了。&lt;/p&gt;

&lt;h2 id=&quot;原则二以应用服务和-api-为视角而不是以资源和技术为视角&quot;&gt;原则二：以应用服务和 API 为视角，而不是以资源和技术为视角&lt;/h2&gt;

&lt;p&gt;国内很多公司都会有很多分工，基本上都会分成运维和开发，运维又会分成基础运维和应用运维，开发则会分成基础核心开发和业务开发。不同的分工会导致完全不同的视角和出发点。比如，基础运维和开发的同学更多的只是关注资源的利用率和性能，而应用运维和业务开发则更多关注的是应用和服务上的东西。这两者本来相关无事，但是因为分布式架构的演进，导致有一些系统已经说不清楚是基础层的还是应用层的了，比如像服务治理上的东西，里面即有底层基础技术，也需要业务的同学来配合，包括 k8s 也样，里面即有底层的如网络这样的技术，也有需要业务配合的 readniess和 liveness 这样的健康检查，以及业务应用需要 configMap 等等 ……&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这些东西都让我感觉到所谓 DevOps，其实就是因为很多技术和组件已经分不清是 Dev 还是 Ops 的了，所以，需要合并 Dev和 Ops&lt;/strong&gt;。而且，整个组织和架构的优化，已经不能通过调优单一分工或是单一组件能够有很大提升的了。其需要有一种自顶向下的，整体规划，统一设计的方式，才能做到整体的提升（可以试想一下城市交通的优化，当城市规模到一定程度的时候，整体的性能你是无法通过优化几条路或是几条街区来完成的，你需要对整个城市做整体的功能体的规划才可能达到整体效率的提升）。而为了做到整体的提升，需要所有的人都要有一个统一的视角和目标，这几年来，我觉得这个目标就是——&lt;strong&gt;要站在服务和 对外API的视角来看问题，而不是技术和底层的角度。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;原则三选择最主流和成熟的技术&quot;&gt;原则三：选择最主流和成熟的技术&lt;/h2&gt;

&lt;p&gt;技术选型是一件很重要的事，技术一旦选错，那会导致整个架构需要做调整，而对架构的调整重来都不是一件简单的事，我在过去几年内，当系统越来越复杂的时候，用户把他们的  PHP，Python, .NET，或 Node.js 的架构完全都迁移到 Java + Go 的架构上来的案例不断的发生。这个过程还是非常痛苦的，但是你没有办法，当你的系统越来越复杂，越来越大时，你就再也不能在一些玩具技术上玩了，你需要的更为工业化的技术。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;尽可能的使用更为成熟更为工业化的技术栈，而不是自己熟悉的技术栈&lt;/strong&gt;。 所谓工业化的技术栈，你可以看看大多数公司使用的技术栈，比如：互联网，金融，电信……等等 ，大公司会有更多的技术投入，也需要更大规模的生产，所以，他们使用的技术通常来说都是比较工业化的。在技术选型上，千万不要被——“你看某个视频公司也在用这个技术”，或是一些在论坛上看到的一些程序员吐槽技术的观点（没有任何的数据，只有自己的喜好）来决定自己的技术，还是看看主流大多数公司实际在用的技术栈，会更靠谱一些。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;选择全球流行的技术，而不是中国流行的技术&lt;/strong&gt;。技术这个东西一定是一个全球化的东西，不是一个局域化的事。所以，一定要选国际化的会更好。另外，千万不要被某些公司的“特别案例”骗过去了，那怕这个案例很性感，关键还是要看解决问题的思路和采用的技术是否具有普世性。只有普世性的技术有更强的生命力。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;尽可能的使用红利大的主流技术，而不要自己发明轮子，更不要魔改&lt;/strong&gt;。我见过好些个公司魔改开源软件，比如有个公司同魔改mesos，最后改着改着发现自己发明另一个 kubernetes。我还见过很多公司或技术团队喜欢自己发明自己的专用轮子，最后都会被主流开源软件所取代。完全没有必要。不重新发明轮子，不魔改，不是因为自己技术不能，而是因为，这个世界早已不是自己干所有事的年代了，这个时代是要想尽方法跟整个产业，整个技术社区融合和合作，这样才会有最大的收益。那些试图因为某个特例需要自成一套的玩法，短期没问题，但长期来说，我都不看好。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;绝大多数情况下，如无非常特殊要求，选 Java基本是不会错的&lt;/strong&gt;。一方面，这是因为 Java 的业务开发的生产力是非常好的，而且有 Spring 框架保障，代码很难写烂，另外，Java 的社区太成熟了，你需要的各种架构和技术都可以很容易获得，技术红利实在是太大。这种运行在JVM上的语言有太多太多的好处了。在 Java 的技术栈上，你的架构风险和架构的成本（无论是人力成本，时间成本和资金成本）从长期来说都是最优的&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在我见过的公司中，好些公司的架构都被技术负责人个人的喜好、擅长和个人经验给绑架了，完全不是从一个客观的角度来进行技术选型。其实，从 0 到 1 的阶段，你用什么样的技术都行，如果你做一个简单的应用，没有事务处理没有复杂的交易流程，比如一些论坛、社交之类的应用，你用任何语言都行。但是如果有一天你的系统变复杂了，需要处理交易了，量也上来了，从 1 到 10，甚至从 10 到 100，你的开发团队也变大了，需要构建的系统越来越大，你可能会发现你只有一个选择，就是 Java。想想京东从.NET 到 Java，淘宝从 PHP 到 Java……&lt;/p&gt;

&lt;p&gt;注，一些有主观喜好的人一定会对我上述对 Java 的描述感到不适，我还用一些证据说明一下——全中国所有的电商平台，几百家银行，三大电信运营商，所有的保险公司，劵商的系统，医院里的系统，电子政府系统，等等，基本都是用 Java 开发的，包括 AWS 的主流语言也是 Java，阿里云一开始用 C++/Python 写控制系统，后面也开始用 Java ……你可能会说 B站是用 go语言，但是你可能不知道 B 站的电商和大数据是用 Java……懂着数据分析的同学，建议上各大招聘网站上搜一下 Java 的职位数量，你就知道某个技术是否主流和热门……&lt;/p&gt;

&lt;h2 id=&quot;原则四完备性会比性能更重要&quot;&gt;原则四：完备性会比性能更重要&lt;/h2&gt;

&lt;p&gt;我发现好些公司的架构师做架构的时候，首要考虑的是架构的性能是否能够撑得住多大多大的流量，而不是考虑系统的完备性和扩展性。所以，我已经多次见过这样的案例了，一开始直接使用 MongoDB 这样的非关系型数据库，或是把数据直接放在 Redis 里，而直接放弃关系型数据库的数据完备性的模型，而在后来需要在数据上进行关系查询的时候，发现 NoSQL 的数据库在 Join 上都表现的太差，然后就开始各种飞线，为了不做 Join 就开始冗余数据，然而自己又维护不好冗余数据后带来的数据一致性的问题，导致数据上的各种错乱丢失。&lt;/p&gt;

&lt;p&gt;所以，我给如下的一些如下的架构原则：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;使用最科学严谨的技术模型为主，并以不严谨的模型作为补充&lt;/strong&gt;。对于上面那个案例来说，就是——永远使用完备支持 ACID 的关系型数据库，然后用 NoSQL 作补充，而不是完全放弃关系型数据库。这里的原则就是所谓的“先紧后松”，一开始紧了，你可以慢慢松，但是开始松了，以后你想紧再也紧不过来了。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;性能上的东西，总是有很多解的&lt;/strong&gt;。我这么多年的经历告诉我，性能上的事，总是有解的，手段也是最多的，这个比起架构的完备性和扩展性来说真的不必太过担心。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了追求所谓的性能，把整个系统的完备性丢失掉，相当地得不偿失。&lt;/p&gt;

&lt;h2 id=&quot;原则五制定并遵循服从标准规范和最佳实践&quot;&gt;原则五：制定并遵循服从标准、规范和最佳实践&lt;/h2&gt;

&lt;p&gt;这个原则是非常重要的，因为只有服从了标准，你的架构才能够有更好的扩展性。比如：我经常性的见到很多公司的系统既没有服从业界标准，也没有形成自己公司的标准，感觉就像一群乌合之众一样。最典型的例子就是 HTTP 调用的状态返回码。业内给你的标准是 200表示成功，3xx 跳转，4xx 表示调用端出错，5xx 表示服务端出错，我实在是不明白为什么无论成功和失败大家都喜欢返回 200，然后在 body 里指出是否error（前两年我在微信公众号里看到一个有一定名气的互联网老兵推荐使用无论正确还是出错都返回 200 的做法，我在后台再三确认后，我发现这样的架构师真是害人不浅）。这样做最大的问题是——监控系统将在一种低效的状态下工作。监控系统需要把所有的网络请求包打开后才知道是否是错误，而且完全不知道是调用端出错还是服务端出错，于是一些像重试或熔断这样的控制系统完全不知道怎么搞（如果是 4xx错，那么重试或熔断是没有意义的，只有 5xx 才有意义）。&lt;strong&gt;有时候，我会有种越活越退步的感觉，错误码设计这种最基本最基础的东西为什么会没有？并且一个公司会任由着大家乱来？这些基础技能怎么就这样丢掉了？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;还有，我还见过一些公司，他们整个组织没有一个统一的用户 ID 的设计，各个系统之间同步用户的数据是通过用户的身份证 ID，是的，就是现实世界的身份证 ID，包括在网关上设置的用户白名单居然也是用身份证 ID。我对这个公司的内的用户隐私管理有很大的担忧。一个企业，一个组织，如果没有标准和规范，也就会有抽象，这一定是要出各种乱子的。&lt;/p&gt;

&lt;p&gt;下面，我罗列一些你需要注意的标准和规范（包括但不限于）：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;服务间调用的协议标准和规范&lt;/strong&gt;。这其中包括 Restful API路径, HTTP 方法、状态码、标准头、自定义头等，返回数据 JSon Scheme……等。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;一些命名的标准和规范&lt;/strong&gt;。这其中包括如：用户 ID，服务名、标签名、状态名、错误码、消息、数据库……等等&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;日志和监控的规范&lt;/strong&gt;。这其中包括：日志格式，监控数据，采样要求，报警……等等&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;配置上的规范&lt;/strong&gt;。这其中包括：操作系统配置、中间件配置，软件包……等等&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;中间件使用的规范&lt;/strong&gt;。数据库，缓存、消息队列……等等&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;软件和开发库版本统一&lt;/strong&gt;。整个组织架构内，软件或开发库的版本最好每年都升一次级，然后在各团队内统一。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里重要说一下两个事：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Restful API 的规范&lt;/strong&gt;。我觉得是非常重要的，这里给两个我觉得写得最好的参考：&lt;a href=&quot;https://github.com/paypal/api-standards/blob/master/api-style-guide.md&quot;&gt;Paypal&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/microsoft/api-guidelines&quot;&gt;Microsoft&lt;/a&gt; 。Restful API 有一个标准和规范最大的好处就是监视可以很容易地做各种统计分析，控制系统可以很容易的做流量编排和调度。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;另一个是服务调用链追踪&lt;/strong&gt;。对于服务调用链追踪来说，基本上都是参考于 &lt;a href=&quot;https://research.google/pubs/pub36356/&quot;&gt;Google Dapper&lt;/a&gt; 这篇论文，目前有很多的实现，最严格的实现是 &lt;a href=&quot;https://zipkin.io/&quot;&gt;Zipkin&lt;/a&gt;，这也是 Spring Cloud Sleuth 的底层实现。Zipkin 贴近 Google Dapper 论文的好处在于——无状态，快速地把 Span 发出来，不消耗服务应用侧的内存和 CPU。这意味着，监控系统宁可自己死了也不能干扰实际应用。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;软件升级&lt;/strong&gt;。我发现很多公司包括 BAT，他们完全没有软件升级的活动，全靠开发人员自发。然而，这种成体系的活动，是永远不可能靠大众的自发形成的。一个公司至少一年要有一次软件版本升级的review，然后形成软件版本的统一和一致，这样会极太简化系统架构的复杂度。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;原则六重视架构扩展性和可运维性&quot;&gt;原则六：重视架构扩展性和可运维性&lt;/h2&gt;

&lt;p&gt;在我见过很多架构里，技术人员只考虑当下，但从来不考虑系统的未来扩展性和可运维性。所谓的管生不管养。如果你生下来的孩子胳膊少腿，严重畸形，那么未来是很难玩的。因为架构和软件不是写好就完的，是需要不断修改不断维护的，80%的软件成本都是在维护上。所以，如何让你的架构有更好的扩展性，可以更容易地运维，这个是比较重要的。所谓的扩展性，意味着，我可以很容易地加更多的功能，或是加入更多的系统，而所谓可运维，就是说我可以对线上的系统做任意的变更。扩展性要求的是有标准规范且不耦合的业务架构，可运维性要求的则是可控的能力，也就是一组各式各样的控制系统。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;通过服务编排架构来降低服务间的耦合&lt;/strong&gt;。比如：通过一个业务流程的专用服务，或是像 Workflow，Event Driven Architecture ， Broker，Gateway，Service Discovery 等这类的的中间件来降低服务间的依赖关系。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;通过服务发现或服务网关来降低服务依赖所带来的运维复杂度&lt;/strong&gt;。服务发现可以很好的降低相关依赖服务的运维复杂度，让你可以很轻松的上线或下线服务，或是进行服务伸缩。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;一定要使用各种软件设计的原则&lt;/strong&gt;。比如：像SOLID这样的原则（参看《&lt;a href=&quot;https://coolshell.cn/articles/4535.html&quot; title=&quot;一些软件设计的原则&quot;&gt;一些软件设计的原则&lt;/a&gt;》），IoC/DIP，SOA 或 Spring Cloud 等 架构的最佳实践（参看《&lt;a href=&quot;https://coolshell.cn/articles/5701.html&quot; title=&quot;SteveY对Amazon和Google平台的吐槽 - 67,710 人阅读&quot;&gt;SteveY对Amazon和Google平台的吐槽&lt;/a&gt;》中的 Service Interface 的那几条军规），分布式系统架构的相关实践（参看：《&lt;a href=&quot;https://coolshell.cn/articles/10910.html&quot; title=&quot;分布式系统的事务处理&quot;&gt;分布式系统的事务处理&lt;/a&gt;》，或微软件的 《&lt;a href=&quot;https://docs.microsoft.com/en-us/azure/architecture/patterns/&quot;&gt;Cloud Design Patterns&lt;/a&gt;》）……等等&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;原则七对控制逻辑进行全面收口&quot;&gt;原则七：对控制逻辑进行全面收口&lt;/h2&gt;

&lt;p&gt;所有的程序都会有两种逻辑，一种是业务逻辑，一种是控制逻辑，业务逻辑就是完成业务的逻辑，控制逻辑是辅助，比如你用多线程，还是用分布式，是用数据库还是用文件，如何配置、部署，运维、监控，事务控制，服务发现，弹性伸缩，灰度发布，高并发，等等，等等 ……这些都是控制逻辑，跟业务逻辑没有一毛钱关系。控制逻辑的技术深度会通常会比业务逻辑要深一些，门槛也会要高一些，所以，最好要专业的程序员来负责控制逻辑的开发，统一规划统一管理，进行收口。这其中包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;流量收口&lt;/strong&gt;。包括南北向和东西向的流量的调度，主要通过流量网关，开发框架 SDK或 Service Mesh 这样的技术。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;服务治理收口&lt;/strong&gt;。包括：服务发现、健康检查，配置管理、事务、事件、重试、熔断、限流……主要通过开发框架 SDK – 如：Spring Cloud，或服务网格Service Mesh等技术。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;监控数据收口&lt;/strong&gt;。包括：日志、指标、调用链……主要通过一些标准主流的探针，再加上后台的数据清洗和数据存储来完成，最好是使用无侵入式的技术。监控的数据必须统一在一个地方进行关联，这样才会产生信息。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;资源调度有应用部署的收口&lt;/strong&gt;。包括：计算、网络和存储的收口，主要是通过容器化的方案，如k8s来完成。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;中间件的收口&lt;/strong&gt;。包括：数据库，消息，缓存，服务发现，网关……等等。这类的收口方式一般要在企业内部统一建立一个共享的云化的中间件资源池。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对此，这里的原则是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;你要选择容易进行业务逻辑和控制逻辑分离的技术&lt;/strong&gt;。这里，Java 的 JVM+字节码注入+AOP 式的Spring 开发框架，会带给你太多的优势。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;你要选择可以享受“前人种树，后人乘凉”的有技术红利的技术&lt;/strong&gt;。如：有庞大社区而且相互兼容的技术，如：Java, Docker,  Ansible，HTTP，Telegraf/Collectd……&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;中间件你要使用可以 支持HA集群和多租户的技术&lt;/strong&gt;。这里基本上所有的主流中间件都会支持 HA 集群方式的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;原则八不要迁就老旧系统的技术债务&quot;&gt;原则八：不要迁就老旧系统的技术债务&lt;/h2&gt;

&lt;p&gt;我发现很多公司都很非常大的技术债务，这些债务具体表现如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;使用老旧的技术&lt;/strong&gt;。比如，使用HTTP1.0， Java 1.6，Websphere，ESB，基于 socket的通讯协议，过时的模型……等等&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;不合理的设计&lt;/strong&gt;。比如，在 gateway 中写大量的业务逻辑，单体架构，数据和业务逻辑深度耦合，错误的系统架构（把缓存当数据库，用消息队列同步数据）……等等&lt;/li&gt;
  &lt;li&gt; &lt;strong&gt;缺少配套设施&lt;/strong&gt;。比如，没有自动化测试，没有好的软件文档，没有质量好的代码，没有标准和规范……等等&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;来找我寻求技术帮助的人都有各种各样的问题。我都会对他们苦口婆心地说同样的一句话——“&lt;strong&gt;如果你是来找我 case-by-case 解决问题，我兴趣不大，因为，你们千万不要寄希望能够很简单的把一辆夏利车改成一辆法拉利跑车，或是把一栋地基没打好的歪楼搞正。以前欠下的技术债，都得要还，没打好的地基要重新打，没建配套设施都要建。这些基础设施如果不按照正确科学的方式建立的话，你是不可能有一个好的的系统，我也没办法帮你 case-by-case 的解决问题……&lt;/strong&gt;”，一开始，他们都会对我说，没问题，我们就是要还债，但是，最后发现要还的债真多，有点承受不了，就开始现原形了。&lt;/p&gt;

&lt;p&gt;他们开始为自己的“欠的技术债”找各种合理化的理由——给你解释各种各样的历史原因和不得以而为之的理由。谈着谈着，让我有一种感觉——他们希望得到一种什么都不改什么都不付出的方式就可以进步的心态，他们宁可让新的技术 low 下来迁就于这些技术债，把新的技术滥用地乱七八糟的。有一个公司，他们的系统架构和技术选型基本都搞错了，使用错误的模型构建系统，导致整个系统的性能非常之差，也才几千万条数据，但他们想的不是还债，不是把地基和配套设施建好，而且要把楼修的更高，上更多的系统——他们觉得现有的系统挺好，性能问题的原因是他们没一个大数据平台，所以要建大数据平台……&lt;/p&gt;

&lt;p&gt;我见过很多很多公司，包括大如 BAT 这样的公司，都会在原来的技术债上进行更多的建设，然后，技术债越来越大，利息越来越大，最终成为一个高利贷，再也还不了（我在《&lt;a href=&quot;https://coolshell.cn/articles/11656.html&quot;&gt;开发团队的效率&lt;/a&gt;》一文中讲过一个 WatchDog 的架构模式，一个系统烂了，不是去改这个系统，而是在旁边建一个系统来看着它，我很难理解为什么会有这样的逻辑，也许是为了要解决更多的就业……）&lt;/p&gt;

&lt;p&gt;这里有几个原则和方法我是非常坚持的，分享给大家：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;与其花大力气迁就技术债务，不如直接还技术债。是所谓的长痛不如短痛。&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;建设没有技术债的“新城区”，并通过“&lt;a href=&quot;https://docs.microsoft.com/en-us/azure/architecture/patterns/anti-corruption-layer&quot;&gt;防腐层&lt;/a&gt; ”的架构模型，不要让技术债侵入“新城区”&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;原则九不要依赖自己的经验要依赖于数据和学习&quot;&gt;原则九：不要依赖自己的经验，要依赖于数据和学习&lt;/h2&gt;

&lt;p&gt;有好些人来找我跟我说他们的技术问题，然后希望我能够给他们一个答案。我说，我需要了解一下你现有系统的情况，也就是需要先做个诊断，我只有得到这些数据后，我才可能明白真正的原因是什么 ，我才可能给你做出一个比较好的技术方案。我个人觉得这是一种对对方负责的方法，因为技术手段太多了，所有的技术手段都有适应的场景，并且有各种 trade-off，所以，只有调研完后才能做出决定。这跟医生看病是一样的，确诊病因不能靠经验，还是要靠诊断数据。在科学面前，所有的经验都是靠不住的……&lt;/p&gt;

&lt;p&gt;另外，如果有一天你在做技术决定的时候，开始凭自己以往的经验，那么你就已经不可能再成长了。人都是不可能通过不断重复过去而进步的，人的进步从来都是通过学习自己不知道的东西。所以，千万不要依赖于自己的经验做决定。做任何决定之前，最好花上一点时间，上网查一下相关的资料，技术博客，文章，论文等 ，同时，也看看各个公司，或是各个开源软件他们是怎么做的？然后，比较多种方案的 Pros/Cons，最终形成自己的决定，这样，才可能做出一个更好的决定。&lt;/p&gt;

&lt;h2 id=&quot;原则十千万要小心-x--y-问题要追问原始需求&quot;&gt;原则十：千万要小心 X – Y 问题，要追问原始需求&lt;/h2&gt;

&lt;p&gt;对于 &lt;a href=&quot;https://coolshell.cn/articles/10804.html&quot; title=&quot;X-Y Problem&quot;&gt;X-Y 问题&lt;/a&gt;，也就是说，用户为了解决 X问题，他觉得用 Y 可以解，于是问我 Y 怎么搞，结果搞到最后，发现原来要解决的 X 问题，这个时候最好的解决方案不是 Y，而是 Z。 这种 X-Y 问题真是相当之多，见的太多太多了。所以，每次用户来找我的时候，我都要不断地追问什么是 X 问题。&lt;/p&gt;

&lt;p&gt;比如，好些用户都会来问我他们要一个大数据流式处理，结果追问具体要解决什么样的问题时，才发现他们的问题是因为服务中有大量的状态，需要把相同用户的数据请求放在同一个服务上处理，而且设计上导致一个慢函数拖慢整个应用服务。最终就是做一下性能调优就好了，根本没有必要上什么大数据的流式处理。&lt;/p&gt;

&lt;p&gt;我很喜欢追问为什么 ，这种追问，会让客户也跟着来一起重新思考。比如，有个客户来找我评估的一个技术架构的决定，从理论上来说，好像这个架构在用户的这个场景下非常不错。但是，这个场景和这个架构是我职业生涯从来没有见过的。于是，我开始追问这个为什么会是这么一个场景？当我追问的时候，我发现用户都感到这个场景的各种不合理。最后引起了大家非常深刻的研讨，最终用户把那个场景修正后，而架构就突然就变成了一个常见且成熟的的模型……&lt;/p&gt;

&lt;h2 id=&quot;原则十一激进胜于保守创新与实用并不冲突&quot;&gt;原则十一：激进胜于保守，创新与实用并不冲突&lt;/h2&gt;

&lt;p&gt;我对技术的态度是比较激进的，但是，所谓的激进并不是瞎搞，也不是见新技术就上，而是积极拥抱会改变未来的新技术，如：Docker/Go，我就非常快地跟进，但是像区块链或是 Rust 这样的，我就不是很积极。因为，其并没有命中我认为的技术趋势的几个特征（参看《&lt;a href=&quot;https://coolshell.cn/articles/18190.html&quot; title=&quot;Go语言、Docker 和新技术&quot;&gt;Go,Docker 和新技术&lt;/a&gt; 》）。当然，我也不是不喜欢的就不学了，我对区块链和 Rust 我一样学习，我也知道这些技术的优势，但我不会大规模使用它们。另外，我也尊重保守的决定，这里面没有对和错。但是，我个人觉得对技术激进的态度比起保守来说有太多的好处了。一方面来说，对于用户来说，很大程度上来说，新技术通常都表面有很好的竞争力，而且我见太多这样成功的公司都在积极拥抱新的技术的，而保守的通常来说都越来越不好。&lt;/p&gt;

&lt;p&gt;有一些人会跟我说，我们是实用主义，我们不需要创新，能解决当下的问题就好，所以，我们不需要新技术，现有的技术用好就行了。这类的公司，他们的技术设计第一天就在负债，虽然可以解决当下问题，但是马上就会出现新的问题，然后他们会疲于解决各种问题。最后呢，最后还是会走到新的技术上。&lt;/p&gt;

&lt;p&gt;这里的逻辑很简单 —— &lt;strong&gt;进步永远来自于探索，探索是要付出代价的，但是收益更大&lt;/strong&gt;。对我而言，不敢冒险才是最大的冒险，不敢犯错才是最大的错误，害怕失去会让你失去的更多……&lt;/p&gt;

&lt;p&gt;原文链接：https://coolshell.cn/articles/21672.html&lt;/p&gt;
</description>
      </item>
    
      <item>
        <title>如何预防和管理技术风险</title>
        <link>http://localhost:4000/%E5%A6%82%E4%BD%95%E9%A2%84%E9%98%B2%E5%92%8C%E7%AE%A1%E7%90%86%E6%8A%80%E6%9C%AF%E9%A3%8E%E9%99%A9</link>
        <pubDate>Mon, 21 Jun 2021 00:00:00 +0800</pubDate>
        <author></author>
        <description>&lt;p&gt;&lt;img src=&quot;/public/images/tech_risk/00.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p align=&quot;right&quot;&gt; “...见微以知萌，见端以知末，故见象箸而怖，知天下不足也。” &lt;/p&gt;

  &lt;p align=&quot;right&quot;&gt; 《韩非子》&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一切线上问题的发生都是有代价的，包括可衡量的直接商业损失，也包括不可衡量的用户或合作方口碑、社会舆情风险、乃至国家监管要求。与普通研发者不同的是，做好技术风险管理需要管理者从技术本身造成的系统风险的视角，延伸至业务影响因素来综合考量，用合理的成本、有效的方法保障业务的连续性。&lt;/p&gt;

&lt;h1 id=&quot;一掌握全貌坚守底线&quot;&gt;一、掌握全貌，坚守底线&lt;/h1&gt;
&lt;p&gt;要做好技术风险管理，管理者必需先掌握技术风险的全貌，而要了解全貌就必需建立风险的明确分级、标准化的管理、以及统一分析度量。&lt;/p&gt;

&lt;h3 id=&quot;建立明确的风险定级标准与标准化风险管理流程&quot;&gt;&lt;strong&gt;建立明确的风险定级标准，与标准化风险管理流程&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;首先需要梳理业务视角的风险等级标准，清晰定义在各场景下的风险应对策略。一般建议在一个业务内统一定义，在跨业务中遵循就高原则，以保障实际运行时针对上下游的业务间对风险分级的标准能够自适应的不断对齐，这样有助于后续标准化管理和流程跑的更加顺畅。级别的定义除了从系统功能影响程度评价，也应综合考量业务影响因素，对高敏感、高风险业务进行适当提高定级标准。&lt;/p&gt;

&lt;p&gt;围绕风险分级标准，就可以建立配套的预防、应急、定责问责等管理流程和制度。如：针对高等级风险，要求必要的防控能力、应急响应时效、各级干系人参与标准，以及更详尽的事件复盘及事后责任评估等。在这些标准化流程约束和执行要求下，能够很快的将风险日常管理在团队内建立起来。&lt;/p&gt;

&lt;h3 id=&quot;建立统一且持续的度量策略关注定期深度分析及持续改进&quot;&gt;&lt;strong&gt;建立统一且持续的度量策略，关注定期深度分析及持续改进&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;在风险管理标准化后，就能对其进行统一度量及固定频率的周期性分析。一般建议根据历史分析、或接下来的软件工程重点，针对性设计标准统一，且持续一定时长的度量策略。这样的度量策略，能够帮助管理者的前置设定目标、并可进行横纵对比，更好的了解风险全貌、评价风险防控工作成果、识别关键突破点。同时要针对多发共性问题、重点风险设定可横向推进的改进策略，保证整体风险管理是从定义管理，到改进预防，人员意识和系统防控能力都是螺旋上升的。&lt;/p&gt;

&lt;p&gt;效率和稳定性常常需要平衡，技术风险防控也需要考虑投入产出。在阿里过去技术风险的规则上，采用了“漏斗”式的分层过滤机制：“鼓励建设 -&amp;gt; 规范运行 -&amp;gt; 警示风险 -&amp;gt; 问责结果”，帮助各研发团队建立逐层风险防御要求，同时可在不同层次投入不同的资源。&lt;/p&gt;

&lt;h3 id=&quot;鼓励更前置的建设投入预防为主防微杜渐&quot;&gt;&lt;strong&gt;鼓励更前置的建设投入，预防为主，防微杜渐&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;更前置的投入风险防控建设往往需要投入的资源更少，但技术风险上的投入对研发而言往往相对业务交付，更不易衡量产出。这就需要从管理者角度，结合对稳定性过程度量，对前置建设投入给与更多的鼓励。在团队中树立典型标杆，以帮助团队中在技术风险相关的优秀工程实践能够被看见，从而能够引导研发在软件研发的前期就更多思考“面向失败的设计”。&lt;/p&gt;

&lt;h3 id=&quot;低风险重在治理高风险明确底线&quot;&gt;&lt;strong&gt;低风险重在治理，高风险明确底线&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;风险一定会发生，在技术风险管理实施过程中，管理者不应过度关注责任，而应将管理重点放到对风险改进的要求上。过度的责任意识，容易使风险管理的执行扭曲变形，导致风险信息的失真，这可能导致更大的风险被隐藏。在技术风险管理策略上，我们针对单次低等级风险事件，建议将重点放在预防、发现、恢复能力的要求上，同时应回归自身，从自身业务风险出发，不断提升上下游能力水位。&lt;/p&gt;

&lt;p&gt;虽然不应过度关注责任，但仍然需要设定底线要求，来帮助尽可能规避不可接受的问题发生，这是风险过滤的最后一道防线。底线要求可以考虑两方面，一是人员意识不足，二是灾难性结果。对意识的要求，可以放在频率最高且风险最高的流程节点，如技术风险针对性设定“变更红线” 来规避意识问题，且这类底线设定需要根据实际水位进行定期调优，以满足持续性和适应性。对灾难性结果，底线设定的要点则是提前声明哪些技术风险影响是不可接受的，如：大额资金损失、严重舆情及品牌风险、国家监管导致的业务关停风险等。&lt;/p&gt;

&lt;h1 id=&quot;二从人的经验不断抽象演进为系统能力&quot;&gt;二、从“人”的经验不断抽象，演进为“系统能力”&lt;/h1&gt;

&lt;p&gt;人是流动的，依靠制度与流程约束达到持续有效的结果是不现实的。这需要管理者在日常就将对人的技术风险管理实践，逐步转移到系统能力建设要求上来。&lt;/p&gt;

&lt;h3 id=&quot;必要的基础运维流程规范的系统化&quot;&gt;&lt;strong&gt;必要的基础运维流程、规范的系统化&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;基于技术风险规范管理者可以引导团队逐步建立基础运维流程的系统化管理能力。如：业务监控部署、变更灰度过程管控、预案覆盖及保鲜、常态化攻防演练等都是可标准实施的基础运维动作，将这些基础运维流程通过系统化管理，可以更好的保障技术风险相关工作的延续性、有效性。&lt;/p&gt;

&lt;h3 id=&quot;建立高可用容灾能力自动化白屏化的运维能力&quot;&gt;&lt;strong&gt;建立高可用容灾能力，自动化、白屏化的运维能力&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;为了避免容易产生误差的手工操作，应尽可能地将标准化运维工作自动化、白屏化。这既能降低因人员交替带来的经验差，也能帮助在故障处理中实现更快速的处置恢复。同时在系统设计中，需要提前考虑避免单点的容灾、容错等机制，这些都需要技术管理者在团队要求上予以明确。&lt;/p&gt;

&lt;h1 id=&quot;三技术风险度量实践参考&quot;&gt;三、技术风险度量实践参考&lt;/h1&gt;
&lt;p&gt;借助标准化的风险管理流程、周期数据分析，往往最先也最易建立结果度量，而易衍生为管理工具。但度量的目标应该是帮助管理者了解现状、引导团队改进，并根据自身发展阶段设计模式，逐步建立过程改进与结果达成的相关性。下面简单介绍，阿里安全生产如何通过度量模式设计引导改进与能力提升，供大家参考。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/images/tech_risk/tech_risk01.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. 结果度量&lt;/strong&gt;：通过目标牵引、统一度量、分解引导三步，使度量更综合，结果更宏观，并具备对比性和引导性。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;目标牵引&lt;/strong&gt;：相对单一问题管理者应更关注总体趋势，这一要求上至 CTO 下至末级团队 TL 应有一致认知。通过一致性的目标定义，可以帮助管理者更好的关注到全局状况和趋势变化。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;统一度量&lt;/strong&gt;：对结果的度量往往有较多指标，如：故障数、E 级故障数、MTTR、客诉量、资损金额等等，诸多因素使得从横向管理角度很难了解整体趋势。为解决这一问题，我们建立了评价单个故障综合状况的统计算式：故障分，通过这一算式综合评价单个故障。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;分解引导&lt;/strong&gt;：有了单个故障综合评价的统计值，再结合单例故障分对团队的分解策略，可起到引导团队改进的效果。如上图所示的分解模式，就定义了对发现和恢复能力建设方面，较原因因素（或通常意义上的责任因素）有更高的要求。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;2. 过程度量&lt;/strong&gt;：关于建立过程度量的要点，我总结为全面丰富的指标、结合工具的改进能力、灵活选择治理重点。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;全面丰富指标&lt;/strong&gt;：根据面向工具、研发者调研，我们发现各 BU 均有自己策略来推动过程建设，这是非常棒的最佳实践，如能横向借鉴将有更好的效果。因此我们建立了，围绕研发运维生命周期中风险治理要求的可拓展的指标框架，并提出“指标市场”概念，“市场”意味着开放接纳与竞争择优。通过“指标市场”的长期建设，能帮助管理者选择更优的指标来推进改进。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;结合工具改进&lt;/strong&gt;：对于指标的基础要求是数据必须是可通过工具系统采集的，其背后的目的是度量的结果是应是可以结合工具进行改进的，这也搭建起了工具使用者与维护者的关联，帮助工具面向风险治理可以不断完善。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;灵活选择重点&lt;/strong&gt;：相较结果度量，过程度量应具备更多的灵活性，来帮助团队发挥自身能动性。选择符合自身场景的指标并应用于改进。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;3. 建立二者的联系&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;最好的结果，是能够逐步建立起两个维度的度量强关联，以保障过程建设与结果的达成直接关联。事实上我们也正朝着这个方向逐步演进，如下的形式已经逐步开始建立链接。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/images/tech_risk/tech_risk02.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;小结&quot;&gt;小结&lt;/h1&gt;
&lt;p&gt;在技术风险预防及管理角度，与研发者不同的是技术管理者应该有更加横向的视角，这体现在掌握全局风险、建立标准管理流程、鼓励前置建设、明确底线要求，同时不断促进经验转化的系统能力建设的管理策略中。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;技术管理者应帮助团队关注到技术风险带来的业务影响的综合评估；&lt;/li&gt;
  &lt;li&gt;技术管理者应要求团队建立标准且统一的风险管理策略，尽可能掌握风险的全貌。结合持续度量与分析了解风险变化趋势，识别关键改进点，持续跟踪闭环；&lt;/li&gt;
  &lt;li&gt;在团队中更多鼓励前置的建设，以最低成本获取最佳的风险规避结果。同时明确底线要求，不断强化来规避不可接受结果的发生；&lt;/li&gt;
  &lt;li&gt;除了管理策略外，技术管理者更应对“将日常技术风险管理的经验、规则，转化为系统流程、能力”提出明确要求，以规避人因风险，也能在在故障应急时保障更自动、更快速的恢复，进而大大提升系统稳定性；&lt;/li&gt;
  &lt;li&gt;综合以上基础要求，管理者应用好度量实践中建议的度量工具，并根据自身发展阶段设计模式，逐步建立过程改进与结果达成的相关性。&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;参考阅读&quot;&gt;参考阅读&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://tr.alibaba-inc.com/portal/article/lzozlw/fzg6dy/gsfby8&quot;&gt;《技术风险规范制度框架》&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://ata.alibaba-inc.com/articles/235146?spm=ata.21736010.0.0.5adc7536Mzfy4q&quot;&gt;《安全生产指南》&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://aws.amazon.com/cn/blogs/china/10-lessons-from-10-years-of-aws/&quot;&gt;《AWS CTO 对过去十年的经验总结 – 十条军规》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
      </item>
    
      <item>
        <title>如何做好技术管理</title>
        <link>http://localhost:4000/%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E6%8A%80%E6%9C%AF%E7%AE%A1%E7%90%86</link>
        <pubDate>Sat, 06 Mar 2021 00:00:00 +0800</pubDate>
        <author></author>
        <description>&lt;p&gt;&lt;img src=&quot;/public/images/tech_manage/00.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p align=&quot;right&quot;&gt; &quot;管理即正确的做事，领导力即做正确的事” &lt;/p&gt;

  &lt;p align=&quot;right&quot;&gt; “Management is doing things right; leadership is doing the right things.”&lt;/p&gt;

  &lt;p align=&quot;right&quot;&gt;Peter Drucker, Effective Executives &lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;软件工程是典型的现代知识工作。其中的“工程”两个字蕴含软件复杂度的本质挑战。我们讨论的软件，基本上都是在一定规模的组织（从几个人团队到几千人不等）内通过不同层次的协同来实现的。 技术管理者所面对的工程，已经不再是以数量来衡量价值产出的，而是如 Peter Drucker 所说的，是通过做正确的事，正确的做事来达成价值。而这些要求，正是卓越工程要解决的问题。因此技术管理是卓越工程的核心环节。&lt;br /&gt;本节重点在&lt;strong&gt;一线研发团队的技术管理实践&lt;/strong&gt;，不涉及更高层级管理者话题或者组织技术战略制定。&lt;/p&gt;

&lt;h1 id=&quot;技术管理核心是支撑团队高效交付价值&quot;&gt;技术管理核心是支撑团队高效交付价值&lt;/h1&gt;
&lt;p&gt;管理者的核心任务是支撑团队高效的交付价值。对于一个软件研发团队来说，交付的价值效率如何衡量？整个研发组织交付业务价值的过程是一个非常复杂的、包含了组织管理、工程效率（协同、复杂度、分析、维护成本）以及研发生产力的多个方面，且多个因素交织在一起的综合过程。 但是我们可以对于价值的交付效率做一个形式上的分解：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/images/tech_manage/tech_manage01.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从这里可以看到，交付价值的过程，包含了三个相互关联的因素：&lt;/p&gt;

&lt;p&gt;（1）&lt;strong&gt;做正确的事&lt;/strong&gt;：通过制定、传达、分解、分析，让团队目标确保在正确方向上，这可能是最关键的部分。&lt;/p&gt;

&lt;p&gt;（2）&lt;strong&gt;工程的复杂度有多高&lt;/strong&gt;？正确的方向有了以后，完成一个研发项目/需求，需要多大的投入？这个过程涉及到方案的确定，其影响因素与需求自身的复杂度有关，但是也与系统本身的复杂度（历史负担，架构合理性）、完成需求的协同成本（一个团队可完成、需要多个团队？）等都有关系。 &lt;br /&gt;（3）&lt;strong&gt;干活效率如何&lt;/strong&gt;： 方向定了，方案也定了，剩下就是干活了。干活的效率和工程师的能力/成长，工具平台是否好用，研发流程是否合理，工作是否能专注有关。&lt;/p&gt;

&lt;p&gt;而不同程度地帮助团队解决好上面几个方面的问题，这就是一线管理者应当发挥的作用。&lt;/p&gt;

&lt;h1 id=&quot;做好技术管理者---理解技术团队&quot;&gt;做好技术管理者 - 理解技术团队&lt;/h1&gt;
&lt;p&gt;首先我们来定义一线研发团队。 一线研发团队一般是由 IC 研发同学组成的，典型的团队由技术线研发工程师为主，有时有测试或者 PM 的同学支持。&lt;/p&gt;

&lt;p&gt;研发团队是做什么的？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;负责一个产品（或者产品模块）/或者系统/子系统的演进&lt;/strong&gt;（Conway 定律，就算这个团队一开始不是负责某个系统/产品，时间长了系统或者产品也会演变成围绕组织边界划分）&lt;/li&gt;
  &lt;li&gt;因为负责相关的产品/模块/系统，&lt;strong&gt;交付业务所需要的需求、功能、部署和维护&lt;/strong&gt;（可能因为 DevOps / SRE 模型的不同这部分的分工有差异）。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/public/images/tech_manage/tech_manage02.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从研发团队自身的定位，我们很容易看到，一个研发团队为了能够实现自身的职责，&lt;strong&gt;需要如下的角色&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;技术负责人&lt;/strong&gt;：项目落实于产品/技术组件/系统，每个产品/系统需要有技术负责人，具体来说技术负责人职责 后面会单独讨论。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;人员管理&lt;/strong&gt;：招聘、绩效、人员日常的管理、团队协同、资源。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;项目管理者&lt;/strong&gt;：研发活动经常以项目形式组织，需要团队内外的协同，项目的推进需要项目管理者的参与，因此这是另一个团队所需要的角色。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;开发&lt;/strong&gt;：研发团队的开发同学。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/public/images/tech_manage/tech_manage03.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;注意角色是会兼任的，如一个人可以同时兼任技术负责人 + 开发。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;研发团队的管理者本身是覆盖哪些角色呢&lt;/strong&gt;？由于我们探讨的是管理者本身，因此“人员管理”的角色职责毫无疑问是在范围内的，那么剩下的就是技术负责人/项目管理，按照不同管理者的职责范围，就有了不同的模型。&lt;/p&gt;

&lt;p&gt;理解团队组成和管理者本身的角色定位，是进一步讨论如何支持团队交付价值的基础。&lt;/p&gt;

&lt;h1 id=&quot;技术管理者如何支撑团队交付价值&quot;&gt;技术管理者如何支撑团队交付价值&lt;/h1&gt;
&lt;p&gt;整个技术团队整体，是以高效的交付价值为目标的。而如何高效交付价值，前面也分解了其中的三个关键要素。管理者在其中围绕交付价值的环节，通过支撑团队发挥作用。&lt;/p&gt;

&lt;h2 id=&quot;1-明确目标---做正确的事&quot;&gt;1. 明确目标 - 做正确的事&lt;/h2&gt;
&lt;p&gt;作为一线团队的主管，很多时候团队的定位和目标在大的组织里面是有相对清晰的定位的，这时，关键要确保&lt;strong&gt;信息的通畅&lt;/strong&gt;。之所以要信息通畅，是因为技术工作的重要特点是团队的一线成员会掌握实时的、更加细节的项目信息，通过信息通畅，才能更好的让团队在执行中避免信息偏差。公司目前推进的 OKR，就是为团队管理提供了面向价值、开放透明的工具。&lt;/p&gt;

&lt;p&gt;如果作为技术管理者，在团队中需要寻找和定义目标，那么可以考虑几个原则：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;明确价值&lt;/strong&gt; - 把&lt;strong&gt;客户价值真正作为最重要的目标&lt;/strong&gt;：客户第一不仅仅是公司的价值观，每个团队在不清楚目标时都值得思考，自己的客户是谁，第一客户是谁。这样的思考也是解决局部利益和全局目标分歧的关键。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;极致务实&lt;/strong&gt;：从目标到每个人应该怎么做，是主管做选择，做什么不做什么的过程。对于一线研发团队，一般不需要涉及复杂的战略取舍，很多时候，就是要求我们做好聚焦，如激光一样聚焦。而取舍，多数时候都是舍的问题。一线的研发团队，&lt;strong&gt;最需要舍的，是那些华而不实、不知道能不能落地、不知道对客户价值有没有用（甚至已经知道没用）的事情。舍弃那些绩效工程、领导工程、放烟花项目、拍脑袋项目&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果说，团队已经有太多的事情了，并没有上面说的这些绩效工程，那还怎么聚焦？有几个简单的判断准则：&lt;/p&gt;

&lt;p&gt;（1）这个事情不做了，对于组织的大目标会有什么影响？ 如果结论是没什么影响，就不必做了。&lt;/p&gt;

&lt;p&gt;（2）如果我的团队，换一个其他的优秀 leader 来带领，他会继续做这个项目吗？如果结论也是不会继续，那我们自己也不用做。&lt;/p&gt;

&lt;p&gt;关于这个问题，各类管理学书籍中探讨比较多，因此后面不再过多展开。这并不是因为这个话题不重要，恰恰相反，做正确的事是技术管理中最重要的话题，只是因为本书无法提供比其他材料更有指导性见解而省略。&lt;/p&gt;

&lt;h2 id=&quot;2-正确的做事---降低工程复杂度和协同成本&quot;&gt;2. 正确的做事 - 降低工程复杂度和协同成本&lt;/h2&gt;

&lt;h3 id=&quot;技术管理者应重视工程质量相关工作支撑团队长期发展&quot;&gt;技术管理者应重视工程质量相关工作，支撑团队长期发展&lt;/h3&gt;
&lt;p&gt;每个技术团队要有技术负责人 tech lead。先说说&lt;strong&gt;什么是技术负责人 tech lead&lt;/strong&gt;。技术负责人负责的不是技术么？是也不是。 负责技术，但是如果没有一个“实在”的东西负责（也就是所谓抓手），其实这个角色就很难发挥作用。 这也是今天很多架构师运转不顺畅的原因，大体上都是没有足够的权责统一。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;技术负责人 tech lead 要负责系统，负责产品&lt;/strong&gt;。 每一个系统/产品，都需要有明确技术负责人。 同时 该系统内部可能还划分几个子系统，可以按照需要设定子系统的技术负责人岗位（当模块/子系统有多于一个工程师参与时）。 子系统技术负责人在技术决策上需要服从上层系统技术决策。&lt;/p&gt;

&lt;p&gt;技术负责人需要承担系统&lt;strong&gt;真正 Owner 的权责，并为结果以及长期演进负责，否则就不是真正的技术负责人&lt;/strong&gt;。大部分的研发团队的管理者本身也兼任团队所负责的系统的技术负责人，但是并不是所有的管理者都有意识的做好了这项工作。当然技术负责人也可以和团队管理者角色分离。今天我们看到不少系统缺乏真正的 Owner，导致很多技术演进问题长期得不到解决，而架构师又难以落地，可以说都是技术负责人角色不清晰导致问题。&lt;/p&gt;

&lt;h3 id=&quot;技术负责人如何发挥作用&quot;&gt;技术负责人如何发挥作用&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;具体来说，如何才算是做好了技术负责人的工作&lt;/strong&gt;？首先，针对我们通常意义上的技术工作的贡献，可以定义一个如下的层次模型：&lt;/p&gt;

&lt;p&gt;-（Level 1）写代码（负责具体实现）
-（Level 2）Review 代码，做方案设计（负责方案落地）
-（Level 3）Review 技术方案设计（负责项目/落地）
-（Level 4）建议新方向，把关新方向（负责整个领域的演进和结果）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/public/images/tech_manage/tech_manage04.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在这四个层次上，一线产品/系统/子系统的技术负责人应该&lt;strong&gt;能够至少覆盖 L2 的工作&lt;/strong&gt;，一线的技术负责人最好还要能够保持 Coding 的工作。而不承担技术负责人的 IC，工作一般会聚焦在 1 和 2 两层上。随着技术负责人自身能力的增长和职责的扩大，会逐渐负责多个子领域，直到负责一个较大的技术领域发展，承担的职责逐渐覆盖到从 L2 到 L3，L4。&lt;/p&gt;

&lt;p&gt;具体如何做 Code Review、代码质量等工程质量相关话题，在本篇后续章节展开。这里关键强调的是，对于技术管理者，&lt;strong&gt;为了团队工程质量/复杂度的降低，必须通过技术负责人的角色长期、坚定的投入&lt;/strong&gt;。对于一线的 TLM 来说，这个技术负责人可以是自己承担，也可以安排团队内最熟悉系统/产品的同学担任，并给予充分的支持让技术负责人真正发挥作用。&lt;/p&gt;

&lt;h3 id=&quot;识别团队内外部协同成本信号积极寻求解决&quot;&gt;识别团队内外部协同成本信号，积极寻求解决&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;安排清晰合理的团队内分工&lt;/strong&gt;。团队内的分工也是个技术架构问题，做好内部的分工，让团队成员可以相互信任和依赖，这是主管的核心职责。&lt;br /&gt;&lt;strong&gt;团队和其他团队边界有冲突时&lt;/strong&gt;，明确边界，解决冲突，是主管应该为团队贡献的工作。同时应该积极&lt;strong&gt;帮助团队解除阻塞&lt;/strong&gt;，通过主动协助团队解决问题或者上升解决&lt;strong&gt;阻塞。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;3-对团队的成员提供支持和帮助---让团队高效工作&quot;&gt;3. 对团队的成员提供支持和帮助 - 让团队高效工作&lt;/h2&gt;

&lt;h3 id=&quot;如何更好的激励团队成员&quot;&gt;如何更好的激励团队成员&lt;/h3&gt;
&lt;p&gt;建设一个能拿结果，有战斗力的团队，团队的成员一定是非常有动力的在工作的。如何能够达到这个状态？首先要强调是在团队的成员和主管之间&lt;strong&gt;构建信任&lt;/strong&gt;。信任的构建是双向的，在高效的组织中，如果缺乏了任何一个方向的信任，都将带来效率的下滑。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;赢得团队的信任&lt;/strong&gt;：作为主管，要能够诚实沟通、有良好的动机（客户第一、帮助员工成长等而非抢夺地盘甚至搞内部政治）、公平对待成员。这种信任来自于主管&lt;strong&gt;真诚的关注成员的发展&lt;/strong&gt;，而不只是自己阶段性的目标。事实上，做到了这一点的团队，只会更有战斗力，能够达成更好的结果。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;相信团队成员&lt;/strong&gt;：主管相信员工，需要做到的是清晰的沟通目标、相信员工的目的和动机是自我实现和带来影响力、主管要提供清晰的组织边界和团队内的结构，从而让组织成员可以相互依赖而不是相互竞争。&lt;a href=&quot;https://rework.withgoogle.com/blog/five-keys-to-a-successful-google-team/&quot;&gt;Google 内部 180 个团队的研究&lt;/a&gt; 清晰揭示了这些组织因素对于团队效率的影响，而其中最重要的是心理安全（在团队中能够安全的进取并承担风险），这需要主管能够给予员工足够的支撑，从而最大化释放出成员的意愿。组织也因此需要 &lt;a href=&quot;https://topic.atatech.org/articles/156422&quot;&gt;Blameless 的文化&lt;/a&gt;，尤其在涉及到故障、事情进展不如人意的时候，深入根因，Blame-aware 但是对复杂的问题不以简单粗暴惩戒来解决。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;同时，作为背景知识，我们每个人都应当了解工程师是如何被激励的&lt;/strong&gt;。推荐所有主管以及希望成为主管的同学仔细看一下 &lt;a href=&quot;https://www.youtube.com/watch?v=u6XAPnuFjJc&quot;&gt;RSA what motivates us&lt;/a&gt; 视频，研发主管需要理解研发活动的本质驱动力：即自主性（Autonomous）、精通（Mastery）和目标（Purpose）。理解研发活动的本质驱动力，我们可以更好的反思自己的角色定位，更多成为一个视人为人的主管，能够赋能团队，能够让同学能够有驱动力并感受到自身的成长，从而带领团队获得更好的结果。&lt;/p&gt;

&lt;h3 id=&quot;通过高效的互动支持团队&quot;&gt;通过高效的互动支持团队&lt;/h3&gt;
&lt;p&gt;在一些管理学的文章上，会把管理的风格归结为不同的类型，有教练型，有代理型等。但是从实际情况看，这些不是工作当中的真正状态。真正在工作当中，针对不同的 团队成员、或者同一个成员在不同的场景下，需要采取不同的模式。 重要的是 在每一个谈话、会议 和讨论之前，我们需要想清楚一个问题： &lt;strong&gt;今天应该用什么模式&lt;/strong&gt;？这个同学，我是应该以指导为主、支持为主还是可以授权给他？ 要有意识的问自己这些问题。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;指导和教练 Coaching&lt;/strong&gt;：适用于两种场景，（1）对于团队的新人、比较初级的工程师，需要采用教练的模式，主管应该花更多的时间，针对具体的案例 帮助同学分析、明确目标、明确路径，教会同学未来遇到同样问题时的解决方案。 具体的可以参考 GROW 模型 [1]；（2）团队成员寻求帮助，这时是 Coaching 的好机会，可以不必急于给出答案，而是帮助同学掌握解决问题的方法&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;支持 Support&lt;/strong&gt;：支持和 Coaching 不同，但可能是管理者最经常的模式，帮助团队的成员解决具体的问题，但是又不是代替成员去决策。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;代理授权 Delegation&lt;/strong&gt;：对于团队的有经验的成员，能够对某个模块、系统、方向承担起相应的职责，我们尽量将职责代理给能够承担的同学。代理是把一件事情或者一个方向的决策权交给这个同学。有同学可以被授权负责某些方向是团队逐渐成熟的很重要标志。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;达成共识 Consensus&lt;/strong&gt;：当前的问题，需要经过引导/讨论/脑爆的模式形成共识，可以设计合理的会议流程和话题引导，给大家充分表达机会，形成共识，促进更好的协同行动。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;直接下达命令 Directing&lt;/strong&gt;：总会有一些场景，因为时间紧迫，没有时间讨论形成共识，那么就明确告诉团队决策，大家按照决策执行。但是不管什么情况，管理者不能带给团队一个不敢反馈的氛围，如果因为自己的管理风格问题导致听不到声音是最危险的。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;具体的细节有很多管理/领导力的书籍可以参考，这里不展开。 关键在于我们要了解这些模式并有意识的选择和应用。&lt;/p&gt;

&lt;h3 id=&quot;注重效率努力纠正一切低效的行为形式主义&quot;&gt;注重效率，努力纠正一切低效的行为、形式主义&lt;/h3&gt;
&lt;p&gt;低效本身是让有追求的同学斗志很容易被消磨的因素。研发流程的效率（具体点很多，工具，平台，测试环境，应用架构的历史债），很多领域已经是破窗效应明显了，&lt;strong&gt;管理者重点是关注团队在研发流程中的效率，并为此负责&lt;/strong&gt;。&lt;br /&gt;会议效率低下，Top-down 的文化等，都不利于研发团队成员高效、专注的工作。 我们需要始终记得，最终工作是靠研发同学的努力完成的，作为主管，需要尽最大努力保护好同学们，让其可以专注工作，而不是用低效的各种琐碎事务干扰同学。&lt;/p&gt;

&lt;h1 id=&quot;结语一切回归到人&quot;&gt;结语：一切回归到人&lt;/h1&gt;
&lt;p&gt;对于技术管理这一节，我们从一个团队高效交付价值讲起，分解了三个不同的要素，并分析了技术管理者如何围绕这三个围绕做好自己的贡献。 所有的这些，最终回归到原点还是要回到人的身上。&lt;/p&gt;

&lt;p&gt;首先，&lt;strong&gt;管理者需要为所带领的研发团队的效率负责&lt;/strong&gt;。 管理者需要明确意识到自己的这一核心职责。&lt;/p&gt;

&lt;p&gt;其次，作为技术公司，我们的技术发展，技术对业务的帮助，这一切根源&lt;strong&gt;都是因为我们吸引了优秀的人才，并且这些人才在公司蓬勃发展&lt;/strong&gt;。有了这个共识，才有技术管理的变化和激活组织的思想基础。&lt;/p&gt;

&lt;h1 id=&quot;实践参考&quot;&gt;实践参考&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;Grow model for coaching and mentoring &lt;a href=&quot;https://www.mindtools.com/pages/article/newLDR_89.htm&quot;&gt;https://www.mindtools.com/pages/article/newLDR_89.htm&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;技术负责人管理办法样例（TRE）：&lt;a href=&quot;https://yuque.antfin.com/docs/share/061389e8-d7d3-4bec-bff6-14547ebb2d70&quot;&gt;https://yuque.antfin.com/docs/share/061389e8-d7d3-4bec-bff6-14547ebb2d70&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;P/M 双通道管理 TODO 待补充文档链接&lt;/li&gt;
  &lt;li&gt;扩展阅读：了解员工驱动力。 RSA what motivated us https://youtu.be/u6XAPnuFjJc&lt;/li&gt;
&lt;/ol&gt;

</description>
      </item>
    
      <item>
        <title>如何做好代码评审</title>
        <link>http://localhost:4000/%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E4%BB%A3%E7%A0%81%E8%AF%84%E5%AE%A1</link>
        <pubDate>Tue, 05 Jan 2021 00:00:00 +0800</pubDate>
        <author></author>
        <description>&lt;p&gt;&lt;img src=&quot;/public/images/code_review/code_review.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p align=&quot;right&quot;&gt; “三人行，必有我师焉；择其善者而从之，其不善者而改之” &lt;/p&gt;

  &lt;p align=&quot;right&quot;&gt;《论语》 &lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;

&lt;p&gt;相信任何对技术有追求的工程师都希望提高自己的编码水平，任何团队都希望产品代码能具有统一风格，代码就像是出自同一人之手，降低认知负荷。&lt;/p&gt;

&lt;p&gt;很多团队也都探索过 Code Review 实践，最终却不幸流于形式，虎头蛇尾，造成这种现象的原因是多方面的，团队文化、奖励机制、成本和收益不对等等问题：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;缺乏 Code Review 文化，没有形成代码评审的统一认知，破窗效应&lt;/li&gt;
  &lt;li&gt;管理者对 Code Review 的关注度不够&lt;/li&gt;
  &lt;li&gt;在评审过程中不知道该关注什么，感受不到 Code Review 带来的收益&lt;/li&gt;
  &lt;li&gt;缺乏 Code Review 最佳实践，导致成本高，在摸索过程中逐渐失去耐心&lt;/li&gt;
  &lt;li&gt;产品业务赶工期，来不及做 Code Review&lt;/li&gt;
  &lt;li&gt;对 Code Review 工具熟悉程度不够&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;1-为什么代码评审很重要&quot;&gt;1. 为什么代码评审很重要&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;工程师成长的最佳场景&lt;/strong&gt;：工程师之间通过 Code Review 对代码设计、实现、规范相关的讨论和交流，是相互学习和成长的最佳场景。软件工程能力只有从代码实践中学到，坚持高标准 Code Review，是团队工程能力提高的必要条件。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;尽早发现 Bug 和设计中存在的问题&lt;/strong&gt;：问题发现得越早，修复的代价越小， Code Review 就是把问题的发现尽量提前。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;团队知识共享&lt;/strong&gt;：代码入库之后，就从个人的代码变成了团队的代码， Code Review 可以帮助其他开发者了解这些代码的设计思想、实现方式，另外， Code Review 的讨论记录、标题、描述信息可以作为参考文档，帮助他人理解代码、追溯逻辑、查找问题。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;针对某个特定方面提高质量&lt;/strong&gt;：针对比较专业的领域，如安全、性能、UI 等，可以邀请专家进行专项审查，另外，复杂场景和高风险代码，也可以通过团队集思广益、查缺补漏的方式来降低上线风险。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;统一编码风格&lt;/strong&gt;：这也是 Code Review 的常见场景，但最好能通过工具，如 Style 插件/P3C 扫描等配置自动化任务来实现机器审查。进行 Code Review ，最好不要过度消耗在风格的检查上。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;引导开发者编程心态&lt;/strong&gt;：如果在编程过程中就知道一定会有同事将检查你的代码，那么你编程心态就会完全不同，会自然而然的更加注重代码质量。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;2-把-code-review-作为一种制度&quot;&gt;2. &lt;strong&gt;把 Code Review 作为一种制度&lt;/strong&gt;&lt;/h1&gt;

&lt;h2 id=&quot;21-发布流水线上配置卡点&quot;&gt;2.1 发布流水线上配置卡点&lt;/h2&gt;
&lt;p&gt;在发布流程中，设置 Code Review 卡点， CR 不通过不允许发布&lt;/p&gt;

&lt;h2 id=&quot;22-代码入库前强制评审&quot;&gt;2.2 代码入库前强制评审&lt;/h2&gt;
&lt;p&gt;如果代码仓库并不利用发布平台进行发布后入库，同时也希望能开发代码入库前的 Code Review 检查，可以在代码平台上开启开关来进行强制入库检查。之后可以通过在本地客户端发起代码评审，可以保证任何 Commit 在入库之前都经过了评审。这种方式可以像提交一个普通分支一样提交评审。&lt;/p&gt;
&lt;div class=&quot;language-powershell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;git&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;origin&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;HEAD:refs/for/&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;分支名&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;title&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;feat: add xxx config&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; 
&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;description&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;a description&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reviewer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xxx&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;3-形成-code-review-文化&quot;&gt;3. 形成 Code Review 文化&lt;/h1&gt;
&lt;p&gt;把 Code Review 作为上线发布流程或者代码入库的卡点并不代表 Code Review 这件事就可以执行的很好。如果仅仅只是当作一个流程制度，那么就可能会流于形式，最终结果就是看起来做了 Code Review ，但没有人认真审查，随便看下就通过了，或者发现问题也不愿意修改。&lt;/p&gt;

&lt;p&gt;要想把 Code Review 这件事做好，必须让 Code Review 变成团队的一种文化，开发人员从心底接受这件事，并认真执行，否则如果只有部分同学认同容易形成破窗效应，久而久之，Code Review 就无法真正执行下去，下列这些方面可以参考：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;开发人员认识到 Code Review 这件事为自己、为团队带来的好处，形成统一的共识比强制执行要事半功倍&lt;/li&gt;
  &lt;li&gt;充分发挥技术带头人和架构师的带头作用，做好表率，榜样的力量很重要&lt;/li&gt;
  &lt;li&gt;对于管理者/架构师/评审人来说，对认真完成 Code Review 的同学以及好的 Code Review 代码实现，不要吝啬自己的赞美，可以通过给 Code Review 点赞和评论等方式给予积极回应&lt;/li&gt;
  &lt;li&gt;把 Code Review 要作为开发任务的一部分，甚至面向 Code Review 编程，一旦面向 Code Review 编程，代码需要经过别人的审核才能入库，你自然而然在意代码质量&lt;/li&gt;
  &lt;li&gt;把 Code Review 当做团队核心的数据资产，也把 Code Review 当做技术人的名片&lt;/li&gt;
  &lt;li&gt;将 Code Review 同步给团队内更多的同学，代码平台支持邮件组通知功能，申请一个公共邮件组，将团队 Leader/架构师等角色组织起来，可以起到很好的监督督促作用&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;4-提高评审效率和评审质量的实践&quot;&gt;4. 提高评审效率和评审质量的实践&lt;/h1&gt;
&lt;p&gt;Code Review 的执行，很大部分程度上依赖于评审人的认真审查，以及被评审人的积极配合，两者缺一不可。但即使是团队已经初步形成了评审文化，但如果评审的成本过高，也会极大的打击评审人和被评审人的积极性，所以必须对 Code Review 进行行为规范来最大程度的降低 Code Review 时间成本，提升评审人和被评审人的沟通效率。这一章节会介绍不同角色对应的 Code Review 规范。&lt;/p&gt;

&lt;h2 id=&quot;41-作为作者&quot;&gt;4.1 作为作者&lt;/h2&gt;

&lt;h3 id=&quot;411-确保-code-review-只做一件事&quot;&gt;4.1.1 确保 Code Review 只做一件事&lt;/h3&gt;
&lt;p&gt;保持单一职责原则可以有效避免 Code Review 成本过高。一个 Code Review 应该只负责一件事，处理了一个 Feature，解决了一个 Bug，新增一个组件或功能。&lt;/p&gt;

&lt;p&gt;单一职责会让 Code Review 理解成本最小，不要为了省事在一个 Code Review 里掺杂太多其它修改，所以下列行为是不推荐的：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在处理需求时觉得的与本需求毫无关联的变量命名写的不好，顺手修改&lt;/li&gt;
  &lt;li&gt;在处理需求时觉得某个与本需求毫无关联的 Method 设计的不优雅，顺手重构&lt;/li&gt;
  &lt;li&gt;在处理需求时发现之前的代码格式不规范，顺手格式化整个文件&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这些行为都是在增加评审成本，应该新起一个独立的 Code Review 来完成，而不是在本次 Code Review 中做。Code Review 的规模和范围并不以代码修改规模来作为唯一评判标准，也要判断该 Code Review 是不是只在做一件事。另外，如果 Code Review 是为了实现代码清理和代码格式化等优化，也不要夹带私货，避免引入 Bugfix 和 Feature。&lt;/p&gt;

&lt;h3 id=&quot;412-发起-code-review-的时机尽量提前开发中小步快跑&quot;&gt;4.1.2 发起 Code Review 的时机：尽量提前，开发中小步快跑&lt;/h3&gt;
&lt;p&gt;避免发起临门一脚的 Code Review，临门一脚指的是快接近发布上线时间才发起的 Code Review，开发代码都是为了发布上线，有一些需求会有发布上线的时间点限制，但发起临门一脚的 Code Review 会显著的将 Code Review 推向流于形式的方向。根据经验，Code Review 越左移，修改代码的成本越低，修改意愿也越高，什么是左移？先了解一下常规的发布上线流水线流程，有两种发起 Code Review 的时机，从 CR 实践落地效果上看，第一种 CR 发起的时机更好&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;时机 1：和 CI 并行的 Code Review 
&lt;img src=&quot;/public/images/code_review/cr01.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;时机 2：在上线发布之前发起 Code Review 
&lt;img src=&quot;/public/images/code_review/cr01-2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;从流水线上来看，许多人会在临近上线时，在靠右的地方快合并主分支的时候才进行 Code Review ，这个时候修改成本就很高，因为代码已经自测/测试通过，如果因为 Code Review 有问题需要重新修改代码，功能本身又要自测或者回归测试，占用更多的时间。而且因为已经临近上线，却因为 Code Review 被打回，开发人员愿意重构代码的意愿也会很低，明明发现问题，又因为上线压力，不打回不符合规范的代码，久而久之大家会失去对 Code Review 的敬畏心理， Code Review 也会慢慢流于形式变成应用发布的过场之一，既无法提高代码质量，降低系统 Bug，也不能提升开发人员的水平，反而降低的开发团队的效率，所以我们要尽量避免在上线之前才发起评审，最好的评审发起时机应该是在开发完毕后立即提交代码评审。但也有一些复杂场景需要反复进行测试和验证，对于这类 Case 也可以在 CI 流程完毕后再发起。&lt;/p&gt;

&lt;h3 id=&quot;413-尽可能提前做好代码自审&quot;&gt;4.1.3 尽可能提前做好代码自审&lt;/h3&gt;

&lt;p&gt;在提交Code Review之前可以借助工具进行一次查缺补漏，避免将低级错误和不完善的代码展现给评审人。例如借助代码平台的新建评审页面展示提交内容，查缺补漏。&lt;/p&gt;

&lt;h3 id=&quot;414-编写语义明确的标题&quot;&gt;4.1.4 编写语义明确的标题&lt;/h3&gt;
&lt;p&gt;不论是 Code Review详情页，还是列表页面，标题都是评审者最先接触到的信息。&lt;/p&gt;

&lt;p&gt;如下图，从评审列表无法判断 Code Review 所完成的事项，是否是在处理 Feature 还是 Bug，也无法判断紧急程度和优先级。&lt;/p&gt;

&lt;p&gt;推荐使用如下格式来规范标题：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;修复线上 bug&lt;/strong&gt;：fix(模块)：标题&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;修复线上紧急 bug&lt;/strong&gt;：紧急 fix(模块)：标题&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;上线新的 feature&lt;/strong&gt;：feature(模块)：标题也有团队使用 feat 来表示 feature&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;模块可以是每个平台约定俗成的模块，比如代码平台的模块包括：Code Search、 Code Review 、Issues、Wiki 等，从评审列表就可以获知大部分信息，当前 Code Review 在解决什么模块的什么问题，也可以根据前缀大概判断紧急程度。规范之后从列表对 Code Review 的意图一目了然，Code Review 也是团队的重要数据资产，通过规范的标题可以对模块的发展脉络进行方便检索。&lt;/p&gt;

&lt;h3 id=&quot;415-编写详细的描述&quot;&gt;4.1.5 编写详细的描述&lt;/h3&gt;
&lt;p&gt;Code Review 的描述也是最重要的信息输入之一，是 Code Review 发起人和代码评审人之间的对话，发起人有义务将自己的编码逻辑、修改范围、可能影响介绍给评审人。评审人在阅读代码之前就了解你的背景和思路，比阅读代码过程中再逐步领悟效率要高得多。评审人也有权利拒绝评审无任何描述信息的 Code Review。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;详细的描述信息能大大降低评审人对你的代码编写逻辑理解成本&lt;/li&gt;
  &lt;li&gt;在编辑描述信息的同时也可以对自己的代码逻辑做进一步的梳理，查缺补漏&lt;/li&gt;
  &lt;li&gt;描述信息也是在代码发布上线后追溯代码修改逻辑的一种重要手段&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;描述部分建议提供以下信息：&lt;/p&gt;
&lt;div class=&quot;language-powershell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;背景：本次修改的原因是什么&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;思路和改动点：大概的思路是什么，改动了哪些方面可能造成的影响介绍一下&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;416-开发过程中的code-review可以使用-wip-前缀来标注&quot;&gt;4.1.6 开发过程中的Code Review可以使用 WIP 前缀来标注&lt;/h3&gt;
&lt;p&gt;WIP：work in progress&lt;br /&gt;评审人在注意到 WIP 开头的 Code Review  时可以暂时忽略&lt;/p&gt;

&lt;p&gt;我们并不能保证每次评审发起后都是一个完整功能或者 fix，例如在发起评审后突然意识到有设计缺陷，或者意识到提交的代码缺少了 UT 覆盖等问题，评审人在不知情的情况下可能随时对你的代码进行评审，为了避免评审人将时间浪费在还未完成开发的 Code Review 上，创建人有义务将标题改成 WIP 前缀，Code 平台会限制这种 Code Review  的合并行为，评审人可以忽略这种评审。&lt;/p&gt;

&lt;h3 id=&quot;417--解决所有-checklist&quot;&gt;4.1.7  解决所有 CheckList&lt;/h3&gt;
&lt;p&gt;每个评审创建人都要对自己的 Code Review  负责，确保 Code Review 达到最终可合并状态，这里的可合并状态并不是有人通过即可，还包括测试用例的状态，Trybots 的状态，评论的状态。 Code Review  会在突出位置展示当前未完成的任务。&lt;/p&gt;

&lt;p&gt;作者需要确保 Code Review 的 Checklist 全部解决，其中包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;确保评审人通过评审&lt;/li&gt;
  &lt;li&gt;解决评论全部解决&lt;/li&gt;
  &lt;li&gt;确保测试卡点任务全部通过&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;418-尊重评审人的评论&quot;&gt;4.1.8 尊重评审人的评论&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;尊重评审人的劳动&lt;/strong&gt;，针对评审人提出建议或者反馈的评论，请给出适当的回应，虽然  Code Review  平台允许创建人将评论置为已解决，但不进行任何回复是不恰当的。&lt;br /&gt;&lt;strong&gt;保持谦逊&lt;/strong&gt;，任何人的代码都可能有改进的空间，哪怕你是这个领域的专家，提交的代码都有可能出现错误，承认不完美才是专业的表现。&lt;/p&gt;

&lt;h3 id=&quot;419-利用格式化扫描插件来实现风格统一&quot;&gt;4.1.9 利用格式化扫描插件来实现风格统一&lt;/h3&gt;
&lt;p&gt;尽管希望借助Code Review来实现代码仓库的风格统一，但将宝贵的精力用于敦促代码风格统一上是得不偿失的，各团队技术负责人配置自动化扫描插件来完成，例如Eslint、P3C、SpotLess。并配置Aone实验室任务、配置CR卡点等。&lt;/p&gt;

&lt;p&gt;针对 Java 语法就有一些常见的风格扫描插件，例如：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;谷歌的 SpotLess ，&lt;a href=&quot;https://github.com/diffplug/spotless&quot;&gt;SpotLess——让你的代码一尘不染&lt;/a&gt;，这个插件不仅可以扫描代码风格，还能帮助格式化代码&lt;/li&gt;
  &lt;li&gt;P3C 代码规约，&lt;a href=&quot;https://1994.github.io/p3c/&quot;&gt;P3C Java 规约扫描&lt;/a&gt; 在 CR 时可以进行扫描格式化&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;42-作为评审人的最佳实践&quot;&gt;4.2 作为评审人的最佳实践&lt;/h2&gt;

&lt;h3 id=&quot;421-尽快评审&quot;&gt;4.2.1 尽快评审&lt;/h3&gt;
&lt;p&gt;把评审代码作为工作的一部分，和开发者尽快发起评审的原则一样，评审人需要留出足够的时间尽快完成评审。越早发现问题，修改代码的成本越低，修改意愿也越高。如果当前没有时间评审，也要明确告诉评审人会在什么时间点前完成，甚至将评审工作转交给其它同事完成。&lt;/p&gt;

&lt;h3 id=&quot;422-对逻辑和质量进行评审&quot;&gt;4.2.2 对逻辑和质量进行评审&lt;/h3&gt;

&lt;h4 id=&quot;4221-实现逻辑&quot;&gt;4.2.2.1 实现逻辑&lt;/h4&gt;

&lt;p&gt;Code Review 应该着重对业务逻辑进行检查&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;逻辑问题&lt;/strong&gt;：是否有未考虑到全局的设计或现有的某些业务细节，边界条件是否考虑充分等&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;安全问题&lt;/strong&gt;：是否存在安全隐患，例如是否存在 SQL 注入、CSRF、越权等安全漏洞&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;性能问题&lt;/strong&gt;：是否会产生性能上的损害，例如慢 SQL、热点 key、数据倾斜等性能问题&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;线上风险&lt;/strong&gt;：是否会对稳定性产生潜在影响，例如是否产生死锁、死循环、FullGC、OOM 等&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;未知影响&lt;/strong&gt;：是否对体验产生潜在影响，例如某 Feature 的上线会潜在影响了其它功能的表现等&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;测试用例&lt;/strong&gt;：是否有有效的单元测试用例验证逻辑，测试用例的分支覆盖度和代码行覆盖等&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;4222-代码质量&quot;&gt;4.2.2.2 代码质量&lt;/h4&gt;
&lt;p&gt;提升代码质量是Code Review的重要目的，Code Review 可以对代码风格、规范、可维护性等进行检查。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;编码规范&lt;/strong&gt;： Code Review 的目的之一是协同，是希望整个团队的代码编写能像出自一人之手&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;可读性&lt;/strong&gt;： Code Review  是一个很好的测验代码可读性的手段，避免使用奇淫巧技，避免过度拆分&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;可维护性&lt;/strong&gt;：代码的可维护性是由很多因素协同作用的结果，代码的可读性好、简洁、可扩展性好，就会使得代码易维护&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;重复度&lt;/strong&gt;：遵守 Don’t Repeat Yourself 原则，尽量减少重复代码的编写，复用已有的代码&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;可测性&lt;/strong&gt;：代码可测试性的好坏，同样可以反应代码质量的好坏，代码的可测试性差难以编写单元测试用例&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;但这部分审查不应该作为评审重点，产品或者技术负责人应当选择合适的扫描插件并配置合适的扫描任务来完成扫描和准入。&lt;/p&gt;

&lt;h3 id=&quot;423-针对代码而不是作者&quot;&gt;4.2.3 针对代码，而不是作者&lt;/h3&gt;
&lt;p&gt;Code Review 针对的是代码而非作者，尽量不要指责代码作者的行为和态度，同时也需要能够接受不同的方案，任何问题总有很多不同的方案，你有的只是你个人倾向的方案，但别人的方案可能同样没有问题。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;对于需要共同遵守的开发规范和一些设计问题，比如代码规约等一定要指出来给予改进&lt;/li&gt;
  &lt;li&gt;对于最佳实践，可以视情况而定，如果是团队已经认可的统一的最佳实践需要明确指出推动改进&lt;/li&gt;
  &lt;li&gt;对于个人风格偏好，可以适当做出一些妥协，比如有的同学习惯把函数拆分的非常小，有的同学就没有这样的习惯，只要不是影响代码理解，这都只是个人习惯，不要做过多争论&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;424-避免过度追求完美&quot;&gt;4.2.4 避免过度追求完美&lt;/h3&gt;
&lt;p&gt;避免苛求每一行的代码都是完美的，避免以找问题的心态进行 Code Review，要抓住 Code Review 的关注重点反馈，另外，并非一定要找到问题才证明你在认真评审，若针对作者的每一行代码评审，很可能会惹恼到作者，也影响到他们对你的反馈的接受。&lt;/p&gt;

&lt;h3 id=&quot;425-不要吝啬自己的赞美&quot;&gt;4.2.5 不要吝啬自己的赞美&lt;/h3&gt;
&lt;p&gt;毫不吝啬的正向反馈也有助于 Code Review 的实践落地，在日常 CR 中，通常的反馈都是问题或建议，鲜有称赞，但代码评审的目的不应该仅仅是发现错误和问题，还应该鼓励和指导开发人员所完成的出色工作。可以通过分享、点赞等方式等来评价。&lt;/p&gt;

&lt;h3 id=&quot;426-明确评论是否要解决&quot;&gt;4.2.6 明确评论是否要解决&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;评审人在发起评论时需要明确指出该评论是否需要被解决&lt;/strong&gt;，代码平台支持评论标签，支持标注评论是否需要被解决，被标注为不需要解决的纯讨论性评论不会被计入 Check List。对于代码修改建议，需要给出明确的论据或者示例。&lt;/p&gt;

&lt;p&gt;另外可以利用标题的描述对 Review 的评论进行分级，告诉开发者应该如何处理这个评论，例如给评论增加Optional前缀。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;[optional]：在评论前面加上一个 [optional] 标记，表示这个代码行的问题可改可不改&lt;/li&gt;
  &lt;li&gt;[optional]：对这个逻辑太复杂的函数进行拆分&lt;/li&gt;
  &lt;li&gt;[optional]：函数的参数太多，建议进行对参数进行封装避免出错&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;427-避免使用反问句来评价&quot;&gt;4.2.7 避免使用反问句来评价&lt;/h3&gt;
&lt;p&gt;避免使用反问句来质疑代码逻辑，通常来说当你 Code Review 代码时保持礼貌和尊重能使开发人员更加清晰，得到更多帮助。也要避免用负面词汇来评价代码。&lt;/p&gt;

&lt;p&gt;🙅🏻‍♀️ 不好的例子: “Catch 异常都不精确的？直接一把抓的？那怎么区分出不同的异常呢？”&lt;/p&gt;

&lt;p&gt;👌 好的例子: “我并没有发现这个并发模块给程序带来了多少帮助，并且还增加了程序的复杂性，因此我认为这段代码最好是用单线程而不是多线程。&lt;/p&gt;

&lt;h1 id=&quot;5-小结&quot;&gt;5. 小结&lt;/h1&gt;
&lt;p&gt;想要推动 Code Review 在团队中更好地实施，很重要的一点便是增强团队成员对 Code Review 的认同感。 如果团队成员不认可 Code Review，即使强制设置了 Code Review 流程，也是形同虚设，反而影响正常开发流程的效率。相反的，如果团队同学都认可“ Code Review 是提升代码质量、提升研发效率的核心手段”，那么团队成员的主观能动性会越来越高，互相学习的氛围越来越浓，帮助别人的同时，也能有效提升自己的代码能力。Code Review 的价值得以最大化，最终实现整体提升研发效率提升。&lt;/p&gt;

&lt;h1 id=&quot;资料引用&quot;&gt;资料引用&lt;/h1&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://phauer.com/2018/code-review-guidelines/?spm=ata.21736010.0.0.21977536LqogJB#code-reviews-guidelines-for-the-reviewer&quot;&gt;https://phauer.com/2018/code-review-guidelines/?spm=ata.21736010.0.0.21977536LqogJB#code-reviews-guidelines-for-the-reviewer&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Google Code Review 规范：&lt;a href=&quot;https://google.github.io/eng-practices/review/&quot;&gt;https://google.github.io/eng-practices/review/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://coolshell.cn/articles/1302.html&quot;&gt;CODE REVIEW中的几个提示&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
      </item>
    
      <item>
        <title>如何写好软件设计文档</title>
        <link>http://localhost:4000/%E5%A6%82%E4%BD%95%E5%86%99%E5%A5%BD%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3</link>
        <pubDate>Wed, 21 Oct 2020 00:00:00 +0800</pubDate>
        <author></author>
        <description>&lt;p&gt;&lt;img src=&quot;/public/images/2020-10-21/design-doc.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;现代软件工程的全过程，有两个阶段非常关键：一个是 “产品设计”，一个是 “架构设计”。&lt;strong&gt;产品设计由产品经理主导，关注的是 “如何以产品特性来系统化地满足用户需求”&lt;/strong&gt;。&lt;strong&gt;架构设计由架构师主导，关注的是 “业务系统如何系统化地进行分解与交付”&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;“设计” 一词非常精妙。无论是 “产品设计”，还是 “架构设计”，其实谈的都是 “需求如何被满足” 这件事情的共识。&lt;/p&gt;

&lt;p&gt;产品经理与架构师是一体两面，对人的能力要求的确会比较像，但是分工不同，关注的维度不同。&lt;strong&gt;产品经理关注的维度，其关键词是：用户需求、技术赋能、商业成功&lt;/strong&gt;。而&lt;strong&gt;架构师关注的维度，其关键词是：用户需求、技术实现、业务迭代&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;本质上所有 “设计文档” 的内容组织逻辑，都应该是相通的。它们的内容大体如下：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. 现状 ：我们在哪里，现状是什么样的？
2. 需求：我们的问题或诉求是什么，要做何改进？
3. 需求满足方式：

    1. 要做成什么样，交付物规格，或者说使用界面（接口）是什么？
    2. 怎么做到？交付物的实现原理。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;设计文档要素的关键在于以下几点。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. 现状：不要长篇累牍。现状更多的是陈述与我们要做的改变相关的重要事实，侧重于**强调这些事实的存在性和重要性**。
2. 需求：同样不需要长篇累牍。痛点只要够痛，大家都知道，所以**需求陈述是对痛点和改进方向的一次共识确认**。
3. 需求满足方式：要详写，**把我们的设计方案谈清楚**。具体来说，它包括 “交付物规格” 和 “实现原理” 两个方面。
4. 交付物规格，**或者说使用界面，体现的是别人要怎么使用我**。对于 “产品设计”，交付物规格可能是 “产品原型”。对于 “架构设计”，交付物规格可能是 “网络 API 协议” 或者 “包（package）导出的公开类或函数”。
5. 实现原理，谈的是我们是怎么做到的。对于 “产品设计”，它谈的是用户需求对应的 UserStory 设计，也就是业务流具体是怎么完成的。而对于 “架构设计”，它谈的是 UserStory 具体如何被我们的程序逻辑所实现。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;程序 = 数据结构 + 算法&lt;/p&gt;

&lt;p&gt;它是一个很好的指导思想。当我们谈程序实现逻辑时，我们总是从数据结构和算法两个维度去描述它。其中，“数据结构” 可以是内存数据结构，也可以是外存数据结构，还可以是数据库的 “表结构”。“算法” 基于 “数据结构”，它描述的是 UserStory 的具体实现，它可以是 UML 时序图（Sequence Diagram），也可以是伪代码（Pseudo Code）&lt;/p&gt;

&lt;h2 id=&quot;多个设计方案的对比&quot;&gt;多个设计方案的对比&lt;/h2&gt;

&lt;p&gt;一篇设计文档有时候不是只有一个设计方案，而是有多个可能的需求实现方式。在这个时候，通常我们会概要地描述清楚两个设计方案的本质差别，并且从如下这些维度进行对比：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. 方案的易实施性与可维护性。
2. 方案的时间复杂度与空间复杂度。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;这是因为 “设计” 是软件工程中的头等大事，我们应该在这里 “多浪费点时间”，这样的 “浪费” 最终会得到十倍甚至百倍以上的回报&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&quot;使用界面接口&quot;&gt;使用界面（接口）&lt;/h2&gt;

&lt;p&gt;对于 “模块的详细设计” 来说，规格描述相对简单。因为我们关注的面只是模块本身，而非模块之间的关系。&lt;strong&gt;对于模块本身，我们核心关注点是以下两点：一是接口是否足够简单，是否自然体现业务需求。二是尽可能避免进行接口变更，接口要向前兼容&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;对于 “系统的概要设计” 来说，我们第一关心的是模块关系，第二关心的才是各个模块的核心接口&lt;/strong&gt;。这些接口能够把系统的关键 UserStory 都串起来。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;对于 UserStory 业务流程的表达来说，UML 时序图通常是更好的表达方式&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;怎么表达模块关系呢？&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;一个方法是对模块的调用接口进行分类，一个模块对外提供的访问接口无非是：常规 DOM API，即正常的模块功能调用；事件（Event）的发送与监听；插件（Plugin）的注册。&lt;/li&gt;
  &lt;li&gt;另一个表达模块关系的视角，是从架构分解看，我们把系统看作 “一个最小化的核心系统 + 多个彼此正交分解的周边系统”&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;需要清楚的是，模块关系图的表达是非常粗糙的，虽然它有助于我们理解系统分解的逻辑。&lt;strong&gt;为了共识的精确，我们仍然需要将各个模块核心的使用界面（接口）表达出来&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&quot;实现原理&quot;&gt;实现原理&lt;/h2&gt;

&lt;p&gt;对于模块的详细设计来说，需要先交代清楚 “数据结构” 是什么样的，然后再将一个个 UserStory 的业务流程讲清楚。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;对于系统的概要设计来说，核心是交代清楚不同模块的配合关系&lt;/strong&gt;，所以无需交代数据结构，只需要把一个个 UserStory 的业务流程讲清楚。&lt;/p&gt;

&lt;p&gt;无论是否要画 UML 时序图，在表达上伪代码（Pseudo Code）的设计都是必需的。&lt;strong&gt;伪代码的表达方式及语义需要在团队内形成默契&lt;/strong&gt;。这种伪代码的语义表达必须是精确的。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;请求&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;post&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bar&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;json&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;err&quot;&gt;#&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;返回&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;json&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以使用 API 来表达&lt;/p&gt;

&lt;h2 id=&quot;qa&quot;&gt;Qa&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;彼此正交就是相互没有直接联系，就算有相互作用也是通过核心系统的接口进行。这里面难点是最小单位的核心系统，需要足够通用的接口方法来保证&lt;/strong&gt;。&lt;/p&gt;
</description>
      </item>
    

  </channel>
</rss>
